-- 面对面交易
local m = {}
m.script_name = 'ToFaceTransActionUI'
_G[m.script_name] = m
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by r.
--- DateTime: 2022/10/26 15:54
---

-----------------------------------------
-- =====================================
--  ----------- 配置部分 --------------
-- =====================================
-----------------------------------------

-----------------------------------------
-- =====================================
--   ----------- 主体 --------------
-- =====================================
-----------------------------------------
local _gt = UILayout.NewGUIDUtilTable()
-- 此界面数据
-- d: data
m.d = {
    -- 进入游戏后就获取到的数据
    -- gsd : global server data
    gsd = GlobalProcessing.ToFaceTransActionUI_server_data,
    --{
    --    -- 不可交易物品KeyName
    --    InhibitoryItemConfig_Key = { "谪剑仙的神器", "烟云客的神器", "冥河使的神器" },
    --    -- 不可交易物品
    --    InhibitoryItemConfig_Type = { { Type = 6 }, { Subtype = 5, Type = 8 }, { Subtype = 7, Subtype2 = 2, Type = 7 } },
    --    -- 货币交易配置
    --    MoneyConfig = { { max_num = 50000, type = 1 }, { max_num = 50000, type = 2 } },
    --    -- 是否使用是否可交易判断
    --    UseItemTradable = true,
    --    -- 显示框的数量
    --    ItemContainerNum = 8,
    --},
    -- 页面数据
    -- pd: page data
    pd = {
        left = {
            player_guid = nil,
            player_name = '张三',
            money_num = { 0, 0 },
            items = {},
            -- 是否锁定
            is_lock = false,
            -- 是否确认
            is_notarize = false,
        },
        right = {
            player_name = '李四',
            money_num = { 0, 0 },
            items = {
                --{
                --      count = 1,
                --      guid = "360676669260831728",
                --      id = "20906",
                --      price = 10,
                --      total = 1
                --}
            },
            -- 是否锁定
            is_lock = false,
            -- 是否确认
            is_notarize = false,
        },
        item_box_bg = {
            normal = '1800300040',
            lock = '1800001160',
            notarize = '1800201130',
        },
    },
}
m.Main = function()
    local wnd = GUI.WndCreateWnd(m.script_name, m.script_name, 0, 0, eCanvasGroup.Normal)
    local panel = UILayout.CreateFrame_WndStyle2(wnd, "面对面交易", 800, 435, m.script_name, "OnExit", _gt, true)
    _gt.BindName(panel, 'panel')
end
-- target_guid: 交易对方玩家的guid
m.OnShow = function(target_guid)
    -- 显示物品的数量
    m.show_item_num = 8

    if target_guid then
        m.d.pd.left.player_guid = target_guid
    end

    -- 再次赋值服务端数据 防止因为顺序而导致nil错误
    if GlobalProcessing.ToFaceTransActionUI_server_data ~= nil then
        m.d.gsd = GlobalProcessing.ToFaceTransActionUI_server_data
        -- 修改显示的数量
        if GlobalProcessing.ToFaceTransActionUI_server_data.ItemContainerNum ~= nil then
            m.show_item_num = GlobalProcessing.ToFaceTransActionUI_server_data.ItemContainerNum
        end
    end

    -- 重置数据
    m.set_empty_page_data()

    local wnd = GUI.GetWnd(m.script_name)
    if wnd then
        GUI.SetVisible(wnd, true)
    end
    local panel = _gt.GetUI('panel')
    m.create(panel)
    m.refresh()
end
-- not_send_req_cancel_the_transaction: 不发送取消交易请求
m.OnExit = function(not_send_req_cancel_the_transaction)
    local wnd = GUI.GetWnd(m.script_name)
    GUI.SetVisible(wnd, false)

    if not_send_req_cancel_the_transaction ~= true then
        m.req_cancel_the_transaction()
    end

    -- 销毁选择物品界面
    --local select_items_ui_group = _gt.GetUI('select_items_ui_group')
    --if select_items_ui_group then
    --    GUI.Destroy(select_items_ui_group)
    --end
    -- 用于物品选择界面
    m.is_close_wnd = true
end

-----------------------------------------
-- =====================================
--   ----------- 创建部分 --------------
-- =====================================
-----------------------------------------
m.create = function(panel)
    if _gt.GetUI('left' .. '_group') then
        return
    end
    m.create_half_part(panel, 'left', 0, 0, GUI.GetWidth(panel) * 0.5, GUI.GetHeight(panel))
    m.create_half_part(panel, 'right', 0, 0, GUI.GetWidth(panel) * 0.5, GUI.GetHeight(panel))
end
-- 创建半个部分
-- @direction : str  方向 是'left'左边部分还是'right'右边部分
m.create_half_part = function(father_panel, direction, x, y, w, h)
    local group = GUI.GroupCreate(father_panel, direction .. '_group', x, y, w, h)
    UILayout.SetSameAnchorAndPivot(group, ((direction == 'left') and UILayout.Left) or ((direction == 'right') and UILayout.Right))
    _gt.BindName(group, direction .. '_group')

    -- 交易物品框
    local items_group = GUI.GroupCreate(group, 'items_group', 0, GUI.GetHeight(group) * 0.15, GUI.GetWidth(group) * 0.8, GUI.GetHeight(group) * 0.5)
    UILayout.SetSameAnchorAndPivot(items_group, UILayout.Top)
    -- 物品scroll
    local scroll = m.create_scroll(items_group, m.show_item_num, direction, 0, 0)
    _gt.BindName(scroll, direction .. '_scroll')
    -- 玩家名称
    local title_img = GUI.ImageCreate(items_group, 'title_img', '1800201220', 0, 1, false, GUI.GetWidth(items_group) * 0.5, 35)
    UILayout.SetSameAnchorAndPivot(title_img, UILayout.Top)
    local title_txt = GUI.CreateStatic(title_img, 'title_txt', '姓名', 0, 0, GUI.GetWidth(title_img), GUI.GetHeight(title_img), 'system')
    GUI.StaticSetFontSize(title_txt, UIDefine.FontSizeM)
    GUI.SetColor(title_txt, UIDefine.WhiteColor)
    GUI.SetIsOutLine(title_txt, true)
    GUI.SetOutLine_Distance(title_txt, 1)
    GUI.SetOutLine_Color(title_txt, UIDefine.BlackColor)
    GUI.StaticSetAlignment(title_txt, TextAnchor.MiddleCenter)

    -- 金钱
    m.create_money_edit(group, direction)

    -- 按钮
    local btn_group_y = ((#m.d.gsd.MoneyConfig <= 0) and -58) or -16
    local btn_group = GUI.GroupCreate(group, 'btn_group', 0, btn_group_y, GUI.GetWidth(group), 50)
    UILayout.SetSameAnchorAndPivot(btn_group, UILayout.Bottom)

    local btn_name = direction .. '_btn'
    local btn_txt = ((direction == 'left') and '取消交易') or ((direction == 'right') and '锁定')
    local btn_img = ((direction == 'left') and '1800402050') or ((direction == 'right') and '1800402040')
    local btn = GUI.ButtonCreate(btn_group, btn_name, btn_img, 0, 0, Transition.ColorTint, btn_txt, 150, 50, false)
    UILayout.SetSameAnchorAndPivot(btn, UILayout.Center);
    GUI.ButtonSetTextColor(btn, UIDefine.WhiteColor);
    GUI.ButtonSetTextFontSize(btn, UIDefine.FontSizeM)
    GUI.SetIsOutLine(btn, true)
    GUI.SetOutLine_Color(btn, UIDefine.OutLine_BrownColor)
    GUI.SetOutLine_Distance(btn, UIDefine.OutLineDistance)
    GUI.RegisterUIEvent(btn, UCE.PointerClick, m.script_name, btn_name .. '_event');
    _gt.BindName(btn, btn_name);

    return group
end

m.create_scroll = function(father_panel, num, direction, x, y)
    -- 滚动限制 当显示物品数量大于此值时开启滚动
    local item_scroll_roll_lock = 8
    -- 每行多少个
    local constraint_count = 4
    -- 格子大小
    local box_size = Vector2.New(80, 80)
    -- 间隔
    local spacing = Vector2.New(1, 1)
    local w = constraint_count * box_size.x + (constraint_count - 1) * spacing.x
    -- 一共有多少行 固定为两行 再多就滚动
    local n_line = math.ceil(item_scroll_roll_lock / constraint_count)
    local h = n_line * box_size.y + (n_line - 1) * spacing.y

    local bg = GUI.ImageCreate(father_panel, 'items_bg', '1800300040', 0, 0, false, w + 10, h + 20)
    UILayout.SetSameAnchorAndPivot(bg, UILayout.Bottom)

    local scroll = GUI.ScrollRectCreate(bg, 'scroll', x, y, w, h, 0, false, box_size, UIAroundPivot.Center, UIAnchor.Center, constraint_count)
    GUI.ScrollRectSetChildSpacing(scroll, spacing)
    -- 当大于限定值时才开启滚动
    GUI.ScrollRectSetVertical(scroll, num > item_scroll_roll_lock)
    UILayout.SetSameAnchorAndPivot(scroll, UILayout.Center)

    for i = 1, num do
        local item_icon = ItemIcon.Create(scroll, "itemIcon_" .. i, 0, 0)
        GUI.SetData(item_icon, 'index', i)
        -- 绿色加号图标
        if direction == 'right' then
            GUI.ItemCtrlSetElementValue(item_icon, eItemIconElement.Icon, '1800707060');
        end
        GUI.RegisterUIEvent(item_icon, UCE.PointerClick, m.script_name, 'on_' .. direction .. '_item_click');
    end

    local lock_bg_group = GUI.GroupCreate(bg, 'lock_bg_group', 0, 0, GUI.GetWidth(bg), GUI.GetHeight(bg))
    local lock_bg = GUI.ImageCreate(lock_bg_group, 'lock_bg', '1800400220', 0, 0, false, GUI.GetWidth(lock_bg_group) - 10, GUI.GetHeight(lock_bg_group) - 10)
    UILayout.SetSameAnchorAndPivot(lock_bg, UILayout.Center)
    _gt.BindName(lock_bg_group, 'lock_bg_group' .. '_' .. direction)
    GUI.SetColor(lock_bg, Color.New(1, 1, 1, 100 / 255))
    local lock_img = GUI.ImageCreate(lock_bg, 'lock_img', '1800408170', 0, 0, true)
    GUI.SetScale(lock_img, Vector3.New(1.5, 1.5, 1))
    GUI.SetColor(lock_img, Color.New(1, 1, 1, 150 / 255))
    UILayout.SetSameAnchorAndPivot(lock_img, UILayout.Center)

    return scroll
end

-- 创建货币输入框
m.create_money_edit = function(father_panel, direction)
    local group = father_panel
    local d = m.d.gsd.MoneyConfig
    local count = #d
    if count > 0 then
        count = ((count > 2) and 2) or count
        -- 金钱
        local money_group = GUI.GroupCreate(group, 'money_group', 0, 110, GUI.GetWidth(group), 50)
        local money_bg_x = ((count == 2) and (((direction == 'left') and 30) or ((direction == 'right') and -30))) or 0
        for i = 1, count do
            local money_bg = GUI.ImageCreate(money_group, 'money_bg_' .. i, '1800001040', money_bg_x, 0, false, GUI.GetWidth(money_group) * 0.4, 45)
            UILayout.SetSameAnchorAndPivot(money_bg, ((count == 2) and (((i == 1) and UILayout.Left) or (i == 2) and UILayout.Right)) or UILayout.Center)

            local x = ((count == 2) and (((i == 1) and 5) or ((i == 2) and -5))) or 5
            local money_type_img = GUI.ImageCreate(money_bg, 'money_type_img', UIDefine.AttrIcon[UIDefine.GetMoneyEnum(d[i].type)], x, 0, false)
            UILayout.SetSameAnchorAndPivot(money_type_img, UILayout.Left)

            local input_field = GUI.EditCreate(money_bg, 'money_input_field', "1800499999", "", 0, 0, Transition.ColorTint, "system", GUI.GetWidth(money_bg) * 0.78, 45, 10, 8, InputType.Standard, ContentType.IntegerNumber)
            UILayout.SetSameAnchorAndPivot(input_field, UILayout.Right)
            GUI.EditSetLabelAlignment(input_field, TextAnchor.MiddleLeft)
            GUI.EditSetFontSize(input_field, UIDefine.FontSizeS)
            GUI.EditSetTextColor(input_field, UIDefine.BrownColor)
            local colorType_Input = Color.New(135 / 255, 135 / 255, 135 / 255)
            GUI.SetPlaceholderTxtColor(input_field, colorType_Input)
            GUI.EditSetMaxCharNum(input_field, 9)
            GUI.EditSetPlaceholderAlignment(input_field, TextAnchor.MiddleLeft)
            -- 左边的无法输入
            if direction == 'left' then
                GUI.EditSetCanEdit(input_field, false)
                GUI.EditSetTextM(input_field, 0)
            else
                -- 货币类型
                GUI.SetData(input_field, 'index', i)
                GUI.RegisterUIEvent(input_field, UCE.PointerClick, m.script_name, 'OnInputFieldClick')
                GUI.RegisterUIEvent(input_field, UCE.EndEdit, m.script_name, "OnInputFieldEndEdit")
            end
            money_bg_x = -money_bg_x
        end
    end
end

-- 创建是否接收交易弹窗
m.create_accept_transaction_pop_up_windows = function(target_guid)
    local player_name = CL.GetRoleName(uint64.new(target_guid))
    m.d.pd.left.player_guid = target_guid
    m.d.pd.right.player_guid = LD.GetSelfGUID()
    GlobalUtils.ShowBoxMsg("提示", player_name .. '向您发起交易，是否接受', m.script_name, "确认", "req_accept_transaction", "取消", "req_dont_accept_transaction", true, 'req_dont_accept_transaction', 1, 60)
end
-----------------------------------------
-- =====================================
--   ----------- 刷新部分 --------------
-- =====================================
-----------------------------------------
m.refresh = function()
    m.refresh_half_part('left')
    m.refresh_half_part('right')
end
-- 刷新半个部分
-- @direction : str  方向 是'left'左边部分还是'right'右边部分
m.refresh_half_part = function(direction)
    local group = _gt.GetUI(direction .. '_group')

    local d = m.d.pd[direction]
    -- 玩家姓名
    local player_name = d.player_name
    local title_txt = GUI.GetChild(group, 'title_txt', true)
    GUI.StaticSetText(title_txt, player_name)

    -- 物品框
    m.refresh_scroll(direction)

    -- 当状态变化时进行刷新
    m.refresh_state_change(direction)

    -- 金钱
    m.refresh_money(direction)

    -- 刷新按钮
    m.refresh_btn(direction)

end

m.refresh_scroll = function(direction)
    --local group = _gt.GetUI(direction .. '_group')
    local d = m.d.pd[direction].items
    local d_count = #d
    --  {
    --  count = 1,
    --  guid = "360676669260831728",
    --  id = "20906",
    --  price = 10,
    --  total = 1
    --}

    -- 锁定背景
    local lock_bg_group = _gt.GetUI('lock_bg_group' .. '_' .. direction)
    GUI.SetVisible(lock_bg_group, m.d.pd[direction].is_lock)
    -- 物品框
    local scroll = _gt.GetUI(direction .. '_scroll')
    for i = 1, m.show_item_num do
        local icon = GUI.GetChild(scroll, 'itemIcon_' .. i)
        -- 如果没有选中数据
        if d_count <= 0 then
            ItemIcon.SetEmpty(icon)
            if direction == 'right' then
                -- 在非锁定的情况下
                if m.d.pd[direction].is_lock == false then
                    -- 加号图片
                    if i == 1 then
                        GUI.ItemCtrlSetElementValue(icon, eItemIconElement.Icon, '1800707060');
                    end
                end
            end
        else
            -- 如果当前遍历到的物品格下标 大于选中的物品的数量
            if i > d_count then
                ItemIcon.SetEmpty(icon)
                if direction == 'right' then
                    -- 在非锁定的情况下
                    if m.d.pd[direction].is_lock == false then
                        -- 选中物品的数量的下一个
                        if d_count + 1 == i then
                            -- 加号图片
                            GUI.ItemCtrlSetElementValue(icon, eItemIconElement.Icon, '1800707060');
                        end
                    end
                end
            else
                local item_d = d[i]
                -- 左边的物品格数据需要做特殊处理，因为当前客户端没有其他客户端的物品信息
                if direction == 'left' then
                    local item_key_name = item_d.keyname
                    ItemIcon.BindItemKeyName(icon, item_key_name)
                else
                    local item_userdata = LD.GetItemDataByGuidInAll(uint64.new(item_d.guid))
                    ItemIcon.BindItemData(icon, item_userdata)
                end
                -- 物品选中的数量  不知道为啥如果是1的时候会不显示
                GUI.ItemCtrlSetElementValue(icon, eItemIconElement.RightBottomNum, item_d.count);
            end
        end
    end
    -- 滚动到开头
    GUI.ScrollRectSetNormalizedPosition(scroll, Vector2.New(0, 1))


end

-- 刷新钱
m.refresh_money = function(direction)

    local group = _gt.GetUI(direction .. '_group')
    local d = m.d.pd[direction].money_num
    -- 金钱
    for k, v in ipairs(d) do
        -- 超出输入范围
        if k > 2 then
            break
        end

        local money_num = v
        local money_bg = GUI.GetChild(group, 'money_bg_' .. k, true)
        local input_field = GUI.GetChild(money_bg, 'money_input_field')
        GUI.EditSetTextM(input_field, money_num)
        -- 如果处于锁定 则不可编辑
        if direction == 'right' then
            GUI.EditSetCanEdit(input_field, not m.d.pd[direction].is_lock)
        end
    end
end

-- 刷新按钮
m.refresh_btn = function(direction)
    if direction == 'right' then
        -- 判断是否确认交易
        if m.d.pd[direction].is_notarize == true then
            m.set_btn_txt_and_available(direction, '确认交易', false)
            -- 判断是否锁定
        elseif m.d.pd[direction].is_lock == true then
            -- 如果对方没有锁定则显示'不可点击的锁定',如果对应也锁定了则显示'可用的确认交易'
            if m.d.pd['left'].is_lock == true then
                m.set_btn_txt_and_available(direction, '确认交易', true)
            else
                m.set_btn_txt_and_available(direction, '锁定', false)
            end
        else
            m.set_btn_txt_and_available(direction, '锁定', true)
        end
    elseif direction == 'left' then
        local name = '取消交易'
        -- 判断自己是否有选中物品
        if #m.d.pd['right'].items > 0 then
            name = '清空物品'
        end
        m.set_btn_txt_and_available(direction, name, ((name == '取消交易') and true) or (not m.d.pd['right'].is_lock))

    end
end

-- 当状态变化时进行刷新 暂不做任何事
m.refresh_state_change = function(direction)
    --local scroll = _gt.GetUI(direction .. '_scroll')
    ---- 增加背景颜色
    --local bg = GUI.GetParentElement(scroll)
    --if m.d.pd[direction].is_notarize == true then
    --    GUI.ImageSetImageID(bg, m.d.pd.item_box_bg.notarize)
    --elseif m.d.pd[direction].is_lock == true then
    --    GUI.ImageSetImageID(bg, m.d.pd.item_box_bg.lock)
    --else
    --    GUI.ImageSetImageID(bg, m.d.pd.item_box_bg.normal)
    --end

    -- 锁定背景
    local lock_bg_group = _gt.GetUI('lock_bg_group' .. '_' .. direction)
    GUI.SetVisible(lock_bg_group, m.d.pd[direction].is_lock)
    local lock_img = GUI.GetChild(lock_bg_group, "lock_img")
    if m.d.pd[direction].is_notarize == true then
        GUI.SetColor(lock_img, Color.New(234 / 255, 212 / 255, 96 / 255, 223 / 255))
    else
        GUI.SetColor(lock_img, Color.New(1, 1, 1, 150 / 255))
    end
end

--- 控制左右两边按钮的显示文本及是否可用
---@param direction str 方向
---@param txt str 显示文本
---@param is_available boolean 是否可用
m.set_btn_txt_and_available = function(direction, txt, is_available)
    local group = _gt.GetUI(direction .. '_group')
    local btn = GUI.GetChild(group, direction .. '_btn', true)
    if txt then
        GUI.ButtonSetText(btn, txt)
    end
    GUI.ButtonSetShowDisable(btn, is_available)
end
-----------------------------------------
-- =====================================
--   ----------- 点击事件 --------------
-- =====================================
-----------------------------------------
-- 左边某个物品格点击
m.on_left_item_click = function(guid)
    local icon = GUI.GetByGuid(guid)
    local index = tonumber(GUI.GetData(icon, 'index'))
    local item_guid = nil
    if index <= #m.d.pd.left.items then
        item_guid = m.d.pd.left.items[index].guid
    end
    if item_guid then
        -- 显示物品tips  因为是其他客户端数据 需要先向服务器查询下
        m.req_get_other_client_item_info(item_guid)
        --m.show_tips(item_guid, 200)
    end
end
-- 右边某个物品格点击
m.on_right_item_click = function(guid)
    if m.d.pd.right.is_lock == true then
        local icon = GUI.GetByGuid(guid)
        local index = tonumber(GUI.GetData(icon, 'index'))
        local item_guid = nil
        if index <= #m.d.pd.right.items then
            item_guid = m.d.pd.right.items[index].guid
        end
        if item_guid then
            -- 显示物品tips
            m.show_tips(item_guid, -200)
        end
    else
        -- 打开选择物品界面
        m.select_items_ui.main()
    end

end
-- 右边货币框点击输入时的事件 未使用
m.OnInputFieldClick = function(guid)
    local edit = GUI.GetByGuid(guid)
    GUI.EditSetTextM(edit, '')
end
-- 右边货币输入框输入结束后事件
m.OnInputFieldEndEdit = function(guid)
    local edit = GUI.GetByGuid(guid)
    local index = tonumber(GUI.GetData(edit, 'index'))
    local last_edit = tonumber(GUI.GetData(edit, 'last_edit'))
    last_edit = ((last_edit == '' or last_edit == nil) and 0) or last_edit
    local d = m.d.gsd.MoneyConfig[index]
    -- 当前输入框的数量
    local cur_edit_count = tonumber(GUI.EditGetTextM(edit))
    if cur_edit_count == nil then
        GUI.EditSetTextM(edit, last_edit)
        return
    end
    -- 服务器交易金额大小限制
    if d.max_num ~= 0 and cur_edit_count > d.max_num then
        CL.SendNotify(NOTIFY.ShowBBMsg, '交易' .. UIDefine.AttrName[UIDefine.GetMoneyEnum(d.type)] .. '不能大于' .. d.max_num)
        GUI.EditSetTextM(edit, last_edit)
        return
    end
    -- 判断自己是否有足够的货币
    local self_ingot_count = tonumber(tostring(CL.GetAttr(UIDefine.GetMoneyEnum(d.type))))
    if cur_edit_count > self_ingot_count then
        CL.SendNotify(NOTIFY.ShowBBMsg, '输入失败，您未拥有足够的' .. UIDefine.AttrName[UIDefine.GetMoneyEnum(d.type)])
        GUI.EditSetTextM(edit, last_edit)
        return
    end

    -- 将数量填入输入框 消除0数值
    GUI.EditSetTextM(edit, cur_edit_count)

    m.d.pd.right.money_num[index] = cur_edit_count
    GUI.SetData(edit, 'last_edit', cur_edit_count)
end
-- 左侧按钮
m.left_btn_event = function(guid)
    local btn = GUI.GetByGuid(guid)
    local txt = GUI.ButtonGetText(btn)
    if txt == '取消交易' then
        m.OnExit()
    elseif txt == '清空物品' then
        -- 清空选中物品数据
        m.d.pd.right.items = {}
        -- 刷新物品框
        m.refresh_scroll('right')
        -- 清空金钱
        m.d.pd.right.money_num = {}
        for i = 1, #m.d.gsd.MoneyConfig do
            table.insert(m.d.pd.right.money_num, 0)
        end
        m.refresh_money('right')
        -- 刷新左边按钮文本
        m.refresh_btn('left')
    end
end
-- 右侧按钮
m.right_btn_event = function(guid)
    local btn = GUI.GetByGuid(guid)
    local txt = GUI.ButtonGetText(btn)
    if txt == '锁定' then
        m.req_lock()
    elseif txt == '确认交易' then
        m.req_confirm_transaction()
    end
end
-----------------------------------------
-- =====================================
--  ----------- 服务器请求 --------------
-- =====================================
-----------------------------------------
-- 取消交易请求
m.req_cancel_the_transaction = function()
    -- 将交易对方玩家的存储的guid删除
    m.d.pd.left.player_guid = nil
    --FormFaceDeal.EndDeal(player)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "EndDeal")
end
-- 取消交易回调
m.rep_cancel_the_transaction = function()
    m.OnExit(true)
end
-- 锁定请求
m.req_lock = function()
    -- 将数据改为锁定
    m.d.pd['right'].is_lock = true
    -- 将右边物品框点击事件改为显示tips  已处理
    -- 刷新物品格列表内的加+图片
    m.refresh_scroll('right')
    -- 当状态变化时进行刷新
    m.refresh_state_change('right')
    -- 将金额输入框改为不可输入
    m.refresh_money('right')
    -- 将按钮设为不可用
    m.refresh_btn('right')
    m.refresh_btn('left')

    -- 发送给服务端的货币数据
    local money_str = m.make_money_str(m.d.pd.right.money_num)
    --FormFaceDeal.DealItemLock(player)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "DealItemLock", money_str)

end
-- 锁定回调
m.rep_lock = function()
    -- 将数据改为锁定
    m.d.pd['left'].is_lock = true
    -- 当状态变化时进行刷新
    m.refresh_state_change('left')
    -- 刷新按钮
    m.refresh_btn('right')

    -- 处理一下服务端传回的金钱数据
    m.d.pd.left.money_num = m.processing_server_money_str(m.d.pd.left.money_num)
    -- 刷新金钱
    m.refresh_money('left')
end
-- 接受交易请求
m.req_accept_transaction = function()
    --FormFaceDeal.StartDeal(player)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "StartDeal")
end
-- 拒接交易请求
m.req_dont_accept_transaction = function()
    --FormFaceDeal.RefusalToDeal(player)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "RefusalToDeal")
end
-- 确认请求
m.req_confirm_transaction = function()
    m.d.pd.right.is_notarize = true
    -- 刷新按钮 让确认交易按钮变为不可用
    m.refresh_btn('right')
    -- 当状态变化时进行刷新
    m.refresh_state_change('right')
    --function FormFaceDeal.ConfirmDeal(player)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "ConfirmDeal")
end
-- 确认回调
m.rep_confirm_transaction = function()
    m.d.pd.left.is_notarize = true
    -- 当状态变化时进行刷
    m.refresh_state_change('left')
end
-- 确认物品请求
m.req_confirm_items = function()
    -- 物品字符串列表 物品guid_物品数量
    local item_guid_str = ''
    for _, v in ipairs(m.d.pd.right.items) do
        local str = v.guid .. '_' .. v.count .. '_'
        item_guid_str = item_guid_str .. str
    end
    -- 发送给服务端的货币数据
    local money_str = m.make_money_str(m.d.pd.right.money_num)
    --FormFaceDeal.DealItemSave(player,guid_str,money_str)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "DealItemSave", item_guid_str, money_str)
end
-- 确认交易物品回调
m.rep_confirm_items = function()
    -- 处理一下从服务端传回的金钱数据
    m.d.pd.left.money_num = m.processing_server_money_str(m.d.pd.left.money_num)

    -- 刷新对方物品
    m.refresh_scroll('left')
    -- 刷新对方金钱
    m.refresh_money('left')
end
-- 获取其他客户端物品信息请求
m.req_get_other_client_item_info = function(item_guid)
    --查看物品详细信息
    --FormFaceDeal.ShowItemData(player,guid)
    CL.SendNotify(NOTIFY.SubmitForm, "FormFaceDeal", "ShowItemData", item_guid)
end
-- 获取其他客户端物品信息回调
m.rep_get_other_client_item_info = function()
    m.show_tips(nil, 200)
end
-----------------------------------------
-- =====================================
--  ----------- 服务器回调 --------------
-- =====================================
-----------------------------------------
-- 交易成功回调
m.req_transaction_success = function()
    -- 双方关闭界面
    m.OnExit(true)
end
-----------------------------------------
-- =====================================
--  ----------- 其他方法 --------------
-- =====================================
-----------------------------------------
-- 将页面数据置为空
m.set_empty_page_data = function()
    local pd = m.d.pd
    for k, v in pairs(pd) do
        if k == 'right' then
            v.player_name = CL.GetRoleName()
        elseif k == 'left' then
            v.player_name = CL.GetRoleName(uint64.new(v.player_guid))
        end
        v.money_num = { 0, 0 }
        v.items = {}
        v.is_lock = false
        v.is_notarize = false
    end

    -- 因为默认数据是两个零，但服务器配置可能不是两个零，所以修改下得和服务器一致
    -- 修改交易金钱的种类数量
    local money_num = {}
    for i = 1, #m.d.gsd.MoneyConfig do
        table.insert(money_num, 0)
    end
    m.d.pd.left.money_num = money_num
    m.d.pd.right.money_num = money_num
end
-- 显示tips
m.show_tips = function(item_guid, x)
    local father_panel = GUI.GetWnd(m.script_name)
    local item_userdata = nil
    if item_guid == nil then
        item_userdata = LD.GetQueryItemData()
    else
        item_userdata = LD.GetItemDataByGuidInAll(item_guid)
    end
    if item_userdata == nil then
        test('Error: ' .. m.script_name .. '显示物品tips时 物品item_userdata为nil ')
    else
        local tips = Tips.CreateByItemData(item_userdata, father_panel, 'item_tips', x, 0)
        UILayout.SetSameAnchorAndPivot(tips, UILayout.Center)
        local CutLine = GUI.GetChild(tips, 'CutLine')
        GUI.SetPositionX(CutLine, x)
    end
end
-- 制作发送给服务端的货币数据 货币类型_货币数量
m.make_money_str = function(money_num)
    if next(m.d.gsd.MoneyConfig) == nil then
        return ''
    end
    local money_str = ''
    for k, v in ipairs(money_num) do
        if k > 2 then
            break
        end
        local type = m.d.gsd.MoneyConfig[k].type
        local str = type .. '_' .. v .. '_'
        money_str = money_str .. str
    end
    return money_str
end
-- 处理从服务端传回来的货币数据
m.processing_server_money_str = function(money_num)
    local items = {}
    for k, _ in ipairs(m.d.gsd.MoneyConfig) do
        table.insert(items, money_num[k * 2])
    end
    return items
end

--
--    ===============================================================================================================
--     ---------------------------------------------- 选择物品界面 ---------------------------------------------------
--    ===============================================================================================================
--
m.select_items_ui = {}
local sui = m.select_items_ui

-- 主方法
sui.main = function()
    -- 如果界面不存在时，界面存在会在sui.create方法中设置显示界面
    if _gt.GetUI('select_items_ui_group') == nil or m.is_close_wnd == true then
        -- 重置数据
        for k, v in pairs(sui) do
            -- 保留sell_scroll_num_max属性 物品格的数量
            if k ~= 'sell_scroll_num_max' then
                if type(v) ~= 'function' then
                    sui[k] = nil
                end
            end
        end
        sui.script_name = 'select_items_ui.'
        -- 能够选中的物品数据列表
        sui.SellItems = sui.filter_bag_items()
        -- 当前页签 为了适用从ShopUI复制过来的代码
        sui.tabIndex = 2
        -- 选中物品列表
        sui.SellSelectItemLst = {}
        -- 创建物品格子每行有多少个
        sui.ITEM_BOXES_LINE_COUNT = 5
        -- 创建物品格子的最小数量 每行5个 5行
        sui.ONEPAGE_COUNT = sui.ITEM_BOXES_LINE_COUNT * 5
        -- 点击物品格后 多长时间开启连点
        sui.PRESS_WAIT_TIME = 5

        -- 物品详情界面需要的数据
        -- 当前选中的物品最大的数量
        sui.itemMaxNum = 0
        -- 右边物品详情页面中输入后需要执行的方法
        sui.numNodify = sui.UpdateSelectItemNum

        -- 筛选界面数据
        sui.SelectList = {
            [1] = { icon = "1900110280", text = "装备" },
            [2] = { icon = "1900920760", text = "宝石" },
            [3] = { icon = "1900040450", text = "信物" },
            [4] = { icon = "1900000630", text = "材料" },
            [5] = { icon = "1900000300", text = "消耗品" },
        }
        sui.QualityList = {
            [1] = { color = UIDefine.WhiteColor, text = "普通" },
            [2] = { color = UIDefine.GreenColor, text = "优秀" },
            [3] = { color = UIDefine.BlueColor, text = "精良" },
            [4] = { color = UIDefine.PurpleColor, text = "史诗" },
            [5] = { color = UIDefine.OrangeColor, text = "传说" },
        }
        sui.SelectQuality = {}
        sui.ruleType = {
            ["装备"] = { Type = 1 },
            ["宝石"] = { Type = 3 },
            ["信物"] = { Type = 6 },
            ["材料"] = { Type = 3 },
            ["消耗品"] = { Type = 2 }
        }

        -- 未筛选中物品数据
        --sui.not_select_items_guid = {}
        -- 清空物品信息界面显示
        sui.ResetDetailArea()

        -- 是否需要重置此选择物品界面数据
        m.is_close_wnd = false

        -- 创建物品格的数量
        if sui.sell_scroll_num_max == nil then
            sui.sell_scroll_num_max = 0
        end
    end

    sui.create()
    -- 在创建后才能拿到
    sui.panelBg = _gt.GetUI('sui_info_bg')
    sui.Refresh()

end

-- 创建界面
sui.create = function()
    local wnd = GUI.GetWnd(m.script_name)
    local select_items_ui_group_name = 'select_items_ui_group'
    local group = _gt.GetUI(select_items_ui_group_name)
    if group then
        GUI.SetVisible(group, true)
        return
    end
    group = GUI.GroupCreate(wnd, select_items_ui_group_name, 0, 0, GUI.GetWidth(wnd), GUI.GetHeight(wnd))
    _gt.BindName(group, select_items_ui_group_name)
    local panelBg = UILayout.CreateFrame_WndStyle2(group, "物品选择", 900, 560, m.script_name, sui.script_name .. "OnExit", _gt, true)
    _gt.BindName(panelBg, 'select_ui_panelBg')

    -- 窗口标题下的部分
    local center = GUI.GetChild(panelBg, 'center')
    local center_w = GUI.GetWidth(center)

    -- 物品格背景
    local scroll_bg = GUI.ImageCreate(center, "ItemScrollBg", "1800400010", center_w * 0.02, 0, false, 500, 480)
    UILayout.SetSameAnchorAndPivot(scroll_bg, UILayout.Left)

    -- 物品格
    local sellScroll = GUI.ScrollRectCreate(scroll_bg, 'sellScroll', 0, 0,
            GUI.GetWidth(scroll_bg), GUI.GetHeight(scroll_bg) - 30, 0, false,
            Vector2.New(85, 85), UIAroundPivot.Top, UIAnchor.Top, sui.ITEM_BOXES_LINE_COUNT)
    GUI.ScrollRectSetChildSpacing(sellScroll, Vector2.New(10, 5))
    _gt.BindName(sellScroll, "sellScroll")

    -- 物品详情
    local infoBg = GUI.ImageCreate(center, "infoBg", "1800400010", -center_w * 0.02, -13, false, 350, 420)
    UILayout.SetSameAnchorAndPivot(infoBg, UILayout.TopRight)
    _gt.BindName(infoBg, 'sui_info_bg')

    -- 三个按钮
    local sellBtn = GUI.ButtonCreate(infoBg, "sellBtn", "1800402080", 0, 58, Transition.ColorTint, "确定", 160, 50, false)
    UILayout.SetSameAnchorAndPivot(sellBtn, UILayout.BottomRight)
    GUI.SetIsOutLine(sellBtn, true)
    GUI.ButtonSetTextFontSize(sellBtn, UIDefine.FontSizeXL)
    GUI.ButtonSetTextColor(sellBtn, UIDefine.WhiteColor)
    GUI.SetOutLine_Color(sellBtn, UIDefine.OutLine_BrownColor)
    GUI.SetOutLine_Distance(sellBtn, UIDefine.OutLineDistance)
    GUI.RegisterUIEvent(sellBtn, UCE.PointerClick, m.script_name, sui.script_name .. "OnSellBtnClick")

    local selectAllBtn = GUI.ButtonCreate(infoBg, "selectAllBtn", "1800402080", 0, 58, Transition.ColorTint, "筛选", 160, 50, false)
    UILayout.SetSameAnchorAndPivot(selectAllBtn, UILayout.BottomLeft)
    _gt.BindName(selectAllBtn, "selectAllBtn")
    GUI.SetIsOutLine(selectAllBtn, true)
    GUI.ButtonSetTextFontSize(selectAllBtn, UIDefine.FontSizeXL)
    GUI.ButtonSetTextColor(selectAllBtn, UIDefine.WhiteColor)
    GUI.SetOutLine_Color(selectAllBtn, UIDefine.OutLine_BrownColor)
    GUI.SetOutLine_Distance(selectAllBtn, UIDefine.OutLineDistance)
    GUI.RegisterUIEvent(selectAllBtn, UCE.PointerClick, m.script_name, sui.script_name .. "SaleScreening")

    --local unSelectAllBtn = GUI.ButtonCreate(infoBg, "unSelectAllBtn", "1800402080", 0, 58, Transition.ColorTint, "取消选中", 160, 50, false)
    --UILayout.SetSameAnchorAndPivot(unSelectAllBtn, UILayout.BottomLeft)
    --_gt.BindName(unSelectAllBtn, "unSelectAllBtn")
    --GUI.SetIsOutLine(unSelectAllBtn, true)
    --GUI.ButtonSetTextFontSize(unSelectAllBtn, UIDefine.FontSizeXL)
    --GUI.ButtonSetTextColor(unSelectAllBtn, UIDefine.WhiteColor)
    --GUI.SetOutLine_Color(unSelectAllBtn, UIDefine.OutLine_BrownColor)
    --GUI.SetOutLine_Distance(unSelectAllBtn, UIDefine.OutLineDistance)
    --GUI.RegisterUIEvent(unSelectAllBtn, UCE.PointerClick, m.script_name, sui.script_name .. "OnUnSelectAllBtnClick")
    --GUI.SetVisible(unSelectAllBtn, false)

    --GUI.GroupCreate(panelBg, "Node", 0, 0, 0, 0)
end

-- 刷新界面
function sui.Refresh()
    local sellScroll = _gt.GetUI("sellScroll")
    local sellCount = sui.SellItems.Count
    sellCount = ((sellCount <= sui.ONEPAGE_COUNT) and sui.ONEPAGE_COUNT) or (math.ceil(sellCount / sui.ITEM_BOXES_LINE_COUNT) * sui.ITEM_BOXES_LINE_COUNT)
    sui.cre_and_ref_sell_item_scroll(sellCount, sui.sell_scroll_num_max)
    -- 滚动到顶部
    GUI.ScrollRectSetNormalizedPosition(sellScroll, Vector2.New(0, 1))
end

-- 关闭界面
sui.OnExit = function()
    local group = _gt.GetUI('select_items_ui_group')
    GUI.SetVisible(group, false)
end
-----------------------------------------
-- =====================================
--  ----------- 创建界面 --------------
-- =====================================
-----------------------------------------
-- 创建并刷新物品格列表
sui.cre_and_ref_sell_item_scroll = function(count, cur_max)
    -- 记录创建过的最大的值
    if count > cur_max then
        sui.sell_scroll_num_max = count
    end
    local for_count = math.max(count, cur_max)
    local sellScroll = _gt.GetUI("sellScroll")
    -- 创建部分
    for i = 1, for_count do
        local curCount = i
        local ItemIconBg = _gt.GetUI('ItemIconBg' .. curCount)
        if ItemIconBg == nil and i <= count then
            -- 物品icon
            ItemIconBg = ItemIcon.Create(sellScroll, "itemIcon" .. curCount, 0, 0)
            _gt.BindName(ItemIconBg, "ItemIconBg" .. curCount)
            ItemIconBg:RegisterEvent(UCE.PointerUp)
            ItemIconBg:RegisterEvent(UCE.PointerDown)
            GUI.RegisterUIEvent(ItemIconBg, UCE.PointerClick, m.script_name, sui.script_name .. "OnSellItemClick")
            GUI.RegisterUIEvent(ItemIconBg, UCE.PointerUp, m.script_name, sui.script_name .. "OnSellItemPointerUp")
            GUI.RegisterUIEvent(ItemIconBg, UCE.PointerDown, m.script_name, sui.script_name .. "OnSellItemPointerDown")

            -- 选中框
            local Select = GUI.ImageCreate(ItemIconBg, "Select", "1800600160", 0, -2, false, 85, 85)
            GUI.SetVisible(Select, false)

            -- 减少按钮
            local decreaseBtn = GUI.ButtonCreate(ItemIconBg, "decreaseBtn", "1800702070", 0, 0, Transition.ColorTint)
            decreaseBtn:RegisterEvent(UCE.PointerUp)
            decreaseBtn:RegisterEvent(UCE.PointerDown)
            GUI.RegisterUIEvent(decreaseBtn, UCE.PointerClick, m.script_name, sui.script_name .. "OnClickMinusBtn")
            GUI.RegisterUIEvent(decreaseBtn, UCE.PointerUp, m.script_name, sui.script_name .. "OnMinusBtnPointerUp")
            GUI.RegisterUIEvent(decreaseBtn, UCE.PointerDown, m.script_name, sui.script_name .. "OnMinusBtnPointerDown")
            GUI.SetVisible(decreaseBtn, false)
            GUI.SetData(decreaseBtn, "itemGUI", GUI.GetGuid(ItemIconBg))
            UILayout.SetSameAnchorAndPivot(decreaseBtn, UILayout.TopRight)

            -- 物品数量
            local Count = GUI.CreateStatic(ItemIconBg, "Count", "99", -10, -8, 80, 25)
            GUI.StaticSetFontSize(Count, UIDefine.FontSizeSS)
            GUI.StaticSetAlignment(Count, TextAnchor.LowerRight)
            GUI.SetIsOutLine(Count, true)
            GUI.SetOutLine_Color(Count, Color.New(0 / 255, 0 / 255, 0 / 255, 255 / 255))
            GUI.SetOutLine_Distance(Count, 1)
            GUI.SetColor(Count, Color.New(255 / 255, 255 / 255, 255 / 255, 255 / 255))
            UILayout.SetSameAnchorAndPivot(Count, UILayout.BottomRight)

        end
    end
    -- 刷新部分
    for i = 1, for_count do
        local curCount = i
        local ItemIconBg = _gt.GetUI('ItemIconBg' .. curCount)
        if ItemIconBg ~= nil then
            -- 隐藏多的物品格
            if i > count then
                GUI.SetVisible(ItemIconBg, false)
            else
                GUI.SetVisible(ItemIconBg, true)
            end
            local guid = GUI.GetGuid(ItemIconBg)
            local index = i
            local datas = { img = "0", count = 0, price = 0, grade = 1, bind = false, guid = "0", type = 0, subType = 0, naijiudu = nil, naijiuduMax = nil, id = '' }
            if sui.SellItems ~= nil and index >= 0 and index <= sui.SellItems.Count then
                datas.count = sui.SellItems[index].amount
                local config = DB.GetOnceItemByKey1(sui.SellItems[index].id)
                datas.bind = sui.SellItems[index].isbound == 1 and true or false
                datas.guid = tostring(sui.SellItems[index].guid)
                if config ~= nil then
                    datas.img = config.Icon
                    datas.price = config.SaleGoldBind
                    datas.grade = config.Grade
                    datas.type = config.Type
                    datas.subType = config.Subtype
                    datas.id = config.Id
                    if config.Type == 1 then
                        if config.Subtype == 7 then
                            datas.naijiudu = sui.SellItems[index]:GetIntCustomAttr("EquipDurableVal")
                            datas.naijiuduMax = sui.SellItems[index]:GetIntCustomAttr("EquipDurableMax")
                        else
                            datas.naijiudu = sui.SellItems[index]:GetIntCustomAttr("DurableNow")
                            datas.naijiuduMax = sui.SellItems[index]:GetIntCustomAttr("DurableMax")
                        end
                    end
                end
            else
                --return
            end

            local item = GUI.GetByGuid(guid)
            if item ~= nil then
                GUI.SetData(item, "index", index)
                GUI.SetData(item, "total", datas.count)
                GUI.SetData(item, "price", datas.price)
                GUI.SetData(item, "guid", datas.guid)
                GUI.SetData(item, 'id', datas.id)
                GUI.ItemCtrlSetElementValue(item, eItemIconElement.Border, UIDefine.ItemIconBg[datas.grade])
            end

            if sui.SelectSellItemIndex == index then
                sui.SelectSellItemCountUI = item
            end

            if datas.img ~= "0" then
                GUI.ItemCtrlSetElementValue(item, eItemIconElement.Icon, datas.img);
                local iconSizeX = 60
                local iconSizeY = 60
                if datas.type == 6 or datas.type == 7 then
                    iconSizeX = 72
                    iconSizeY = 74
                end
                GUI.ItemCtrlSetElementRect(item, eItemIconElement.Icon, 0, -1, iconSizeX, iconSizeY);
            else
                GUI.ItemCtrlSetElementValue(item, eItemIconElement.Icon, nil);
            end

            local itemIcon = item
            -- 如果是未筛选中的物品 则将其变灰
            local is_gray = ((sui.not_select_items_guid and sui.not_select_items_guid[datas.guid] == true) and true) or false
            GUI.ItemCtrlSetIconGray(itemIcon, is_gray)

            --IconMask和RightBottomSp
            if datas.naijiuduMax and datas.naijiuduMax == 0 then
                --无限耐久
                GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.IconMask, nil);
                GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.RightBottomSp, nil);
            else
                if datas.naijiudu then
                    if datas.naijiudu <= 0 then
                        GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.IconMask, 1801300230);
                        GUI.ItemCtrlSetElementRect(itemIcon, eItemIconElement.IconMask, 0, 0, 80, 81);
                        GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.RightBottomSp, 1800408430);
                        GUI.ItemCtrlSetElementRect(itemIcon, eItemIconElement.RightBottomSp, 0, 0, 22, 23);
                    else
                        GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.IconMask, nil);
                        GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.RightBottomSp, nil);
                    end
                else
                    GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.IconMask, nil);
                    GUI.ItemCtrlSetElementValue(itemIcon, eItemIconElement.RightBottomSp, nil);
                end
            end

            if datas.bind == true then
                GUI.ItemCtrlSetElementValue(item, eItemIconElement.LeftTopSp, 1800707120);
                GUI.ItemCtrlSetElementRect(item, eItemIconElement.LeftTopSp, 0, 0, 44, 45);
            else
                GUI.ItemCtrlSetElementValue(item, eItemIconElement.LeftTopSp, nil);
            end

            local strGUID = tostring(datas.guid)
            if sui.SellSelectItemLst[strGUID] ~= nil then
                sui.OnCheckItemForUI(guid, true, tostring(sui.SellSelectItemLst[strGUID].count) .. "/" .. sui.SellSelectItemLst[strGUID].total)
            else
                local Select = GUI.GetChild(item, "Select")
                if Select ~= nil then
                    GUI.SetVisible(Select, false)
                end
                local decreaseBtn = GUI.GetChild(item, "decreaseBtn")
                if decreaseBtn ~= nil then
                    GUI.SetVisible(decreaseBtn, false)
                end
                local Count = GUI.GetChild(item, "Count")
                if Count ~= nil then
                    GUI.StaticSetText(Count, tostring(datas.count))
                    GUI.SetVisible(Count, datas.count > 0)
                end
            end
            local decreaseBtn = GUI.GetChild(item, "decreaseBtn")
            if decreaseBtn ~= nil then
                GUI.SetData(decreaseBtn, "itemGUID", guid)
            end
        end
    end
end
-- =====================================
--  ----------- 刷新部分 --------------
-- =====================================

-- =====================================
--  -------- 小部分刷新部分 -----------
-- =====================================
-- 修改指定物品格的选中框、减少按钮显示，及物品数量
function sui.OnCheckItemForUI(guid, select, numInfo)
    local item = GUI.GetByGuid(guid)
    local Select = GUI.GetChild(item, "Select")
    if Select ~= nil then
        GUI.SetVisible(Select, select)
    end
    local decreaseBtn = GUI.GetChild(item, "decreaseBtn")
    if decreaseBtn ~= nil then
        GUI.SetVisible(decreaseBtn, select)
    end
    local Count = GUI.GetChild(item, "Count")
    if Count ~= nil then
        GUI.StaticSetText(Count, numInfo)
    end
end
-- 更新总价格
--function sui.OnUpdateSellTotalPrice()
--    local totalPrice = 0
--    for i, v in pairs(sui.SellSelectItemLst) do
--        totalPrice = totalPrice + v.count * v.price
--    end
--
--    local totalCount = _gt.GetUI("totalCount")
--    if totalCount ~= nil then
--        GUI.StaticSetText(totalCount, tostring(totalPrice))
--    end
--end
-- 确定显示什么按钮 当没有选中物品时显示筛选 其他显示取消选中
--function sui.OnSelectAllBtnState()
--    local totalCount = 0
--    for i, v in pairs(sui.SellSelectItemLst) do
--        totalCount = totalCount + 1
--        break
--    end
--
--    local btn = _gt.GetUI("selectAllBtn")
--    if btn then
--        GUI.SetVisible(btn, totalCount == 0)
--    end
--    btn = _gt.GetUI("unSelectAllBtn")
--    if btn then
--        GUI.SetVisible(btn, totalCount > 0)
--    end
--end
-- 修改右边物品信息页面中物品选中的数量
function sui.SetSellNum(num)
    local SellCountEdit = _gt.GetUI("SellCountEdit")
    if SellCountEdit then
        GUI.EditSetTextM(SellCountEdit, tostring(num))
    end
end
function sui.ShowSellNumNode(show)
    local num_group = _gt.GetUI('num_group')
    if num_group then
        GUI.SetVisible(num_group, show)
    end
end
-- 刷新物品列表 及左边物品详情界面
function sui.OnUpdateSellList()
    local index = 1
    if sui.SellItems ~= nil then
        local Count = sui.SellItems.Count
        --包裹更新了，刷新数据
        local sellScroll = _gt.GetUI("sellScroll")
        local sellCount = ((Count <= sui.ONEPAGE_COUNT) and sui.ONEPAGE_COUNT) or (math.ceil(Count / sui.ITEM_BOXES_LINE_COUNT) * sui.ITEM_BOXES_LINE_COUNT)
        sui.cre_and_ref_sell_item_scroll(sellCount, sui.sell_scroll_num_max)

        --显示第一件选中的道具属性
        if sui.SellItems ~= nil and sui.SellItems.Count > 0 then
            -- 已选中物品列表中有数据
            if next(sui.SellSelectItemLst) ~= nil then
                -- 遍历能够选中的物品列表
                for k, v in pairs(sui.SellItems) do
                    if type(v) == 'userdata' and v.guid then
                        if sui.SellSelectItemLst[tostring(v.guid)] then
                            index = k
                            break
                        end
                    end
                end
            end

            local itemData = sui.SellItems[index]
            -- 这参数很蠢且重复
            sui.ShowDetailInfo(sui.PackRealItemInfos(sui.SellItems[index].id, sui.SellItems[index].dyn_attrs, sui.SellItems[index].isbound == 1 and true or false, sui.SellItems[index].amount, true, itemData), sui.panelBg, sui.tabIndex, _gt)
        end
    end
    -- 刷新价格
    --sui.OnUpdateSellTotalPrice()
    -- 选择显示哪一个按钮
    --sui.OnSelectAllBtnState()
    return index
end
function sui.OnCheckIsRemovedAllElements()
    local isClear = true
    for k, v in pairs(sui.SellSelectItemLst) do
        if sui.SellSelectItemLst[k] ~= nil then
            isClear = false
            break
        end
    end
    if isClear then
        sui.ShowDetailInfo(nil, sui.panelBg, sui.tabIndex, _gt)
        sui.ShowSellNumNode(false)
    end
end
-- =====================================
--  ----------- 点击事件 --------------
-- =====================================
function sui.OnPressedOneItem()
    sui.PressedCounter = sui.PressedCounter + 1
    if sui.PressedCounter >= sui.PRESS_WAIT_TIME then
        sui.PressedItemGuid = sui.long_press_item_btn_guid
        sui.OnSellItemClick(sui.PressedItemGuid)
    end
end

function sui.OnSellItemPointerUp(guid)
    if sui.PressedTimer then
        sui.PressedTimer:Stop()
        sui.PressedTimer = nil
    end
end

function sui.OnSellItemPointerDown(guid)
    sui.PressedCounter = 0
    --sui.PressedItemGuid = guid
    -- 缓存下 当执行到满足PressedCounter 才把值赋值给当前选中的物品guid
    sui.long_press_item_btn_guid = guid
    if sui.PressedTimer == nil then
        sui.PressedTimer = Timer.New(sui.OnPressedOneItem, 0.1, -1)
    end
    sui.PressedTimer:Start()
end
-- 物品格点击事件
function sui.OnSellItemClick(guid)
    local item = GUI.GetByGuid(guid)
    local index = 0
    -- 因为物品格中的减少按钮和物品格共用同一个sui.PressedItemGuid当前选中的数据变量，
    -- 导致有时候guid是减少按钮的，从而拿不出total等数据

    -- 判断是否是减少按钮的，如果拿不出数据则不是减少按钮
    local item_guid = GUI.GetData(item, "itemGUI")
    if item_guid == nil or item_guid == '' then
    else
        item = GUI.GetByGuid(item_guid)
    end
    guid = GUI.GetGuid(item) or guid
    if item ~= nil then
        local num = tonumber(GUI.GetData(item, "total"))
        local price = tonumber(GUI.GetData(item, "price"))
        local itemGUID = tostring(GUI.GetData(item, "guid"))
        local id = tostring(GUI.GetData(item, 'id'))
        index = tonumber(GUI.GetData(item, "index"))
        if itemGUID ~= "0" then
            sui.OnCheckItem(guid, true, num, price, itemGUID, nil, id)
        end
        sui.SelectSellItemCountUI = item
        if sui.SellSelectItemLst[itemGUID] ~= nil then
            sui.SetSellNum(sui.SellSelectItemLst[itemGUID].count)
        end
    end

    if sui.SellItems ~= nil and index >= 0 and index <= sui.SellItems.Count then
        --设置当前操作索引
        sui.SelectSellItemTotalCount = sui.SellItems[index].amount
        local num_group = _gt.GetUI('num_group')
        if index ~= sui.SelectSellItemIndex or num_group and not GUI.GetVisible(num_group) then
            sui.SelectSellItemIndex = index
            -- 当前选中的物品格guid
            sui.PressedItemGuid = guid
            local itemData = sui.SellItems[index]
            sui.ShowDetailInfo(sui.PackRealItemInfos(sui.SellItems[index].id, sui.SellItems[index].dyn_attrs, sui.SellItems[index].isbound == 1 and true or false, sui.SellItems[index].amount, true, itemData), sui.panelBg, sui.tabIndex, _gt)
            sui.ShowSellNumNode(true)
        end
    end
end

-- 物品格减少按钮事件部分
function sui.OnPressedMinusBtn()
    sui.PressedCounter = sui.PressedCounter + 1
    if sui.PressedCounter >= sui.PRESS_WAIT_TIME then
        sui.PressedItemGuid = sui.long_press_item_btn_guid
        sui.OnClickMinusBtn(sui.PressedItemGuid)
    end
end

function sui.OnMinusBtnPointerUp(guid)
    if sui.PressedTimer then
        sui.PressedTimer:Stop()
        sui.PressedTimer = nil
    end
end

function sui.OnMinusBtnPointerDown(guid)
    sui.PressedCounter = 0
    --sui.PressedItemGuid = guid
    sui.long_press_item_btn_guid = guid
    if sui.PressedTimer == nil then
        sui.PressedTimer = Timer.New(sui.OnPressedMinusBtn, 0.1, -1)
    end
    sui.PressedTimer:Start()
end

-- 物品格减少按钮点击事件
function sui.OnClickMinusBtn(guid)
    local btn = GUI.GetByGuid(guid)
    local index = 0
    if btn ~= nil then
        local item = nil
        -- 判断是否是减少按钮 如果拿不到此数据则是物品格
        local item_guid = GUI.GetData(btn, "itemGUI")
        if item_guid == nil or item_guid == '' then
            item = btn
        else
            item = GUI.GetByGuid(item_guid)
        end
        guid = GUI.GetGuid(item) or guid
        if item ~= nil then
            local num = tonumber(GUI.GetData(item, "total"))
            local price = tonumber(GUI.GetData(item, "price"))
            local itemGUID = tostring(GUI.GetData(item, "guid"))
            local id = tostring(GUI.GetData(item, 'id'))
            index = tonumber(GUI.GetData(item, "index"))
            if itemGUID ~= "0" then
                sui.OnCheckItem(guid, false, num, price, itemGUID, nil, id)
            end

            --右侧数量栏
            local Count = sui.SellSelectItemLst[itemGUID] and sui.SellSelectItemLst[itemGUID].count or 0
            sui.SetSellNum(Count)

            sui.SelectSellItemCountUI = item

        end


        -- 减少按钮也必须添加刷新右边物品详情界面的功能  不然当前显示的物品详情界面 与点击的减少按钮的物品不同时就会导致数量变了 但是详情界面物品没变
        if sui.SellItems ~= nil and index >= 0 and index <= sui.SellItems.Count then
            --设置当前操作索引
            sui.SelectSellItemTotalCount = sui.SellItems[index].amount
            local num_group = _gt.GetUI('num_group')
            if index ~= sui.SelectSellItemIndex or num_group and not GUI.GetVisible(num_group) then
                sui.SelectSellItemIndex = index
                -- 当前选中的物品格guid
                sui.PressedItemGuid = guid
                local itemData = sui.SellItems[index]
                sui.ShowDetailInfo(sui.PackRealItemInfos(sui.SellItems[index].id, sui.SellItems[index].dyn_attrs, sui.SellItems[index].isbound == 1 and true or false, sui.SellItems[index].amount, true, itemData), sui.panelBg, sui.tabIndex, _gt)
                sui.ShowSellNumNode(true)
            end
        end

    end
end

-- 筛选按钮点击事件
function sui.SaleScreening()

    local wnd = _gt.GetUI("select_items_ui_group")
    local SaleScreeningGroup = GUI.GetChild(wnd, "SaleScreeningGroup", false)

    if not SaleScreeningGroup then
        local width = 600
        local height = 400
        SaleScreeningGroup = GUI.GroupCreate(wnd, "SaleScreeningGroup", 0, 0, GUI.GetWidth(wnd), GUI.GetHeight(wnd))
        _gt.BindName(SaleScreeningGroup, "SaleScreeningGroup")
        local SaleScreeningPanelBg = UILayout.CreateFrame_WndStyle2(SaleScreeningGroup, "筛选", width, height, m.script_name, sui.script_name .. "OnExitSaleScreeningGroup")
        sui.CreateSaleScreeningPanel(SaleScreeningPanelBg)
    else
        GUI.SetVisible(SaleScreeningGroup, true)
    end
end

-- 取消选中点击事件
--function sui.OnUnSelectAllBtnClick()
--    sui.SellSelectItemLst = {}
--    if sui.SellItems ~= nil then
--        -- 刷新物品框列表
--        local Count = sui.SellItems.Count
--        local sellScroll = _gt.GetUI("sellScroll")
--        local sellCount = ((Count <= sui.ONEPAGE_COUNT) and sui.ONEPAGE_COUNT) or (math.ceil(Count / sui.ITEM_BOXES_LINE_COUNT) * sui.ITEM_BOXES_LINE_COUNT)
--        GUI.LoopScrollRectSetTotalCount(sellScroll, sellCount)
--        GUI.LoopScrollRectRefreshCells(sellScroll)
--        -- 刷新显示按钮
--        --sui.OnSelectAllBtnState()
--
--        --sui.OnUpdateSellList()
--    end
--    sui.PressedItemGuid = nil
--    --隐藏物品详情
--    sui.ShowDetailInfo(nil, sui.panelBg, sui.tabIndex, _gt)
--    sui.ShowSellNumNode(false)
--    sui.SelectSellItemIndex = -1
--end

-- 确定按钮点击事件
sui.OnSellBtnClick = function(guid)
    local select_items = {}
    -- 对选中数据进行排序
    for _, v in pairs(sui.SellSelectItemLst) do
        table.insert(select_items, v)
    end
    -- 判断数量是否超过限定
    if #select_items > m.show_item_num then
        CL.SendNotify(NOTIFY.ShowBBMsg, '选中的物品数量不能超过' .. m.show_item_num .. '个')
        return select_items
    end
    table.sort(select_items, sui.item_sort)
    m.d.pd.right.items = select_items
    m.refresh_scroll('right')
    m.refresh_btn('left')

    -- 发送确认物品请求
    m.req_confirm_items()
    sui.OnExit()
    return select_items
end
-- =====================================
--  ----------- 其他方法 --------------
-- =====================================
-- 物品排序规则
sui.item_sort = function(a, b)
    local item_a_db = DB.GetOnceItemByKey1(a.id)
    local item_b_db = DB.GetOnceItemByKey1(b.id)
    -- 品质
    if item_a_db.Grade ~= item_b_db.Grade then
        return item_a_db.Grade > item_b_db.Grade
        -- id
    elseif a.id ~= b.id then
        return a.id < b.id

        -- count
        -- a.count 会报错 所以采用此种方式判断是否为空
    elseif pcall(function()
        return a.count
    end) and pcall(function()
        return b.count
    end) and a.count ~= b.count then
        return a.count > b.count

        -- total
    elseif pcall(function()
        return a.total
    end) and pcall(function()
        return b.total
    end) and a.total ~= b.total then
        return a.total > b.total

        -- amount
    elseif pcall(function()
        return a.amount
    end) and pcall(function()
        return b.amount
    end) and a.amount ~= b.amount then
        return a.amount > b.amount

        -- guid
    elseif a.guid ~= b.guid then
        return a.guid < b.guid
    else
        return true
    end
    return true
end
-- 过滤出能够选中的物品
sui.filter_bag_items = function()
    local items = {}
    -- 获取所有背包 再遍历每个背包的物品数量 然后遍历每个背包的物品
    -- 需要遍历的背包 物品背包、宝石背包、侍从信物背包、仓库背包
    local bag_types = { 'item_container_bag', 'item_container_gem_bag', 'item_container_guard_bag' }
    for _, v in ipairs(bag_types) do
        -- 背包物品数量
        local count = LD.GetItemCount(item_container_type[v])
        for i = 0, count - 1 do
            local item_userdata = LD.GetItemDataByIndex(i, item_container_type[v])
            -- 返回数据的样式
            --[[
            {
                -- 物品guid
                guid,
                -- 物品id
                id,
                -- 拥有这guid
                role_guid,
                -- 物品所在位置
                site,
                -- 战斗物品位置
                battlesite,
                -- 当前的堆叠数量
                amount,
                --是否已绑定
                isbound,
                --绝对时间起始或存活时间
                life,
                --动态属性数据
                dyn_attrs,
            }
            --]]
            if item_userdata ~= nil then
                -- 过滤无法选中的
                -- 过滤掉绑定的
                if item_userdata.isbound == 1 then
                    goto continue1
                end
                local item_db = DB.GetOnceItemByKey1(item_userdata.id)
                -- key_name 过滤
                for _, f1 in ipairs(m.d.gsd.InhibitoryItemConfig_Key) do
                    if item_db.KeyName == f1 then
                        goto continue1
                    end
                end
                -- type 过滤
                -- 记录这次循环的结果如何内循环匹配结果为true，则这次循环也为true，这个数据就应该被过滤
                local is_filter1 = false
                for _, f2 in ipairs(m.d.gsd.InhibitoryItemConfig_Type) do
                    -- 记录这次循环内是否全部匹配，如果全部匹配则为true,否则为false且跳出这次循环
                    local is_filter2 = true
                    for k, t in pairs(f2) do
                        if item_db[k] ~= t then
                            is_filter2 = false
                            break
                        end
                    end
                    if is_filter2 == true then
                        is_filter1 = true
                        break
                    end
                end
                -- 过滤这个数据
                if is_filter1 then
                    goto continue1
                end
                -- 根据服务器配置 判断是否要经过这个过滤
                -- 根据表中的Tradable字段判断是否过滤
                if m.d.gsd.UseItemTradable == true then
                    if item_db.Tradable ~= 1 then
                        goto continue1
                    end
                end
                -- 将数据添加到表
                table.insert(items, item_userdata)
            end
            :: continue1 ::
        end
    end

    -- 对数据进行排序
    table.sort(items, sui.item_sort)

    items.Count = #items
    return items
end
-- 点击物品格时检查数据
function sui.OnCheckItem(guid, isAdd, num, price, itemGUID, forceSetNum, id)
    if forceSetNum ~= nil then
        if forceSetNum > 0 then
            if sui.SellSelectItemLst[itemGUID] == nil then
                sui.SellSelectItemLst[itemGUID] = { count = forceSetNum, total = num, price = price, guid = itemGUID, id = id }
            end
            sui.SellSelectItemLst[itemGUID].count = forceSetNum
            sui.OnCheckItemForUI(guid, true, tostring(sui.SellSelectItemLst[itemGUID].count) .. "/" .. num)
        else
            sui.SellSelectItemLst[itemGUID] = nil
            sui.OnCheckItemForUI(guid, false, num)
        end
    else
        if isAdd then
            if sui.SellSelectItemLst[itemGUID] == nil then
                sui.SellSelectItemLst[itemGUID] = { count = 1, total = num, price = price, guid = itemGUID, id = id }
                sui.OnCheckItemForUI(guid, true, "1/" .. num)
            else
                if sui.SellSelectItemLst[itemGUID].count < num then
                    sui.SellSelectItemLst[itemGUID].count = sui.SellSelectItemLst[itemGUID].count + 1
                    sui.OnCheckItemForUI(guid, true, tostring(sui.SellSelectItemLst[itemGUID].count) .. "/" .. num)
                else
                    CL.SendNotify(NOTIFY.ShowBBMsg, "已达上限")
                end
            end
        else
            if sui.SellSelectItemLst[itemGUID] ~= nil and sui.SellSelectItemLst[itemGUID].count > 0 then
                sui.SellSelectItemLst[itemGUID].count = sui.SellSelectItemLst[itemGUID].count - 1
            end

            if sui.SellSelectItemLst[itemGUID] == nil or sui.SellSelectItemLst[itemGUID].count <= 0 then
                sui.OnCheckItemForUI(guid, false, num)
                -- 当选中数量为0时停止减少按钮事件
                sui.OnMinusBtnPointerUp()
                sui.SellSelectItemLst[itemGUID] = nil
                sui.OnCheckIsRemovedAllElements()
                sui.SelectSellItemIndex = -1
            else
                sui.OnCheckItemForUI(guid, true, tostring(sui.SellSelectItemLst[itemGUID].count) .. "/" .. num)
            end
        end
    end

    --sui.OnUpdateSellTotalPrice()
    --sui.OnSelectAllBtnState()
end

-- 打包需要的物品信息
function sui.PackRealItemInfos(itemID, atts, bind, num, showDetail, itemData)
    local attrTables = sui.PackItemBaseInfo(itemID)
    local itemConfig = DB.GetOnceItemByKey1(itemID)

    showDetail = showDetail or false
    if itemConfig ~= nil then
        local itemType = itemConfig.Type
        attrTables.bind = bind
        attrTables.maxNum = num
        --装备分类
        --显示基本类型，调用统一tip显示
        if showDetail and itemType == 1 then
            attrTables.func = nil
            attrTables.equipTurnBorn = itemConfig.TurnBorn
            attrTables.equipLevel = itemConfig.Level
            attrTables.role = itemConfig.Role

            if itemData then
                --基础属性
                local t = {}
                LogicDefine.GetItemDynAttrDataByMark(itemData, LogicDefine.ItemAttrMark.Base, LogicDefine.ItemAttrMark.Enhance, t)
                if #t > 0 then
                    for i = 1, #t do
                        local value = tostring(t[i].value)
                        if t[i].Id ~= 0 then
                            if t[i].IsPct then
                                value = tostring(tonumber(value) / 100) .. "%"
                            end
                            local attDesc = t[i].name .. "   " .. value
                            table.insert(attrTables.atts, attDesc)
                        end
                    end
                end

                --特效
                local Equip_SpecialEffect = itemData:GetIntCustomAttr("Equip_SpecialEffect")
                local SpecialEffect = DB.GetOnceSkillByKey1(Equip_SpecialEffect)
                if SpecialEffect.Name ~= nil then
                    table.insert(attrTables.atts, "特效：【" .. tostring(SpecialEffect.Name) .. "】")
                end
                --特技
                local Equip_Stunt = itemData:GetIntCustomAttr("Equip_Stunt")
                local Stunt = DB.GetOnceSkillByKey1(Equip_Stunt)
                if Stunt.Name ~= nil then
                    table.insert(attrTables.atts, "特技：【" .. tostring(Stunt.Name) .. "】")
                end

                --强化属性
                local t = {}
                LogicDefine.GetItemDynAttrDataByMark(itemData, LogicDefine.ItemAttrMark.Base, LogicDefine.ItemAttrMark.Enhance, t)
                local exv = "强化等级：   "
                local exMax = UIDefine.MaxIntensifyLevel
                local ulongVal = itemData:GetIntCustomAttr(LogicDefine.EnhanceLv)
                local enhanceLv, h = int64.longtonum2(ulongVal)
                if enhanceLv > 0 then
                    exv = exv .. enhanceLv
                    if exMax then
                        exv = exv .. "/" .. exMax
                    end
                    table.insert(attrTables.intensifyInfo, exv)
                    local intensifyInfo_attrs = {}
                    if #t > 0 then
                        for i = 1, #t do
                            local value = tostring(t[i].exV)
                            if t[i].Id ~= 0 then
                                if t[i].IsPct then
                                    value = tostring(tonumber(value) / 100) .. "%"
                                end
                                table.insert(intensifyInfo_attrs, t[i].name .. "   " .. value)
                            end
                        end
                        table.insert(attrTables.intensifyInfo, intensifyInfo_attrs)
                    end
                end


                --宝石属性
                local gemCount, siteCount = LogicDefine.GetEquipGemCount(itemData)
                if gemCount > 0 then
                    --GUI.TipsAddLabel(itemTips, 20, "宝石镶嵌：    " .. gemCount .. "/" .. siteCount, UIDefine.Yellow3Color, false)
                    table.insert(attrTables.gemInfo, "宝石镶嵌：    " .. gemCount .. "/" .. siteCount)
                    local gemInfo_attrs = {}
                    for i = 1, siteCount do
                        local gemId = itemData:GetIntCustomAttr(LogicDefine.ITEM_GemId_ .. i)
                        if gemId ~= 0 then
                            local gemDB = DB.GetOnceItemByKey1(gemId)
                            --GUI.TipsAddLabel(itemTips, 20, gemDB.Name .. "：", UIDefine.BlueColor, false)
                            table.insert(gemInfo_attrs, tostring(gemDB.Name))
                            local attrDatas = itemData:GetDynAttrDataByMark(LogicDefine.ITEM_GemAttrMark[i])
                            local GemAttribute = ""
                            for i = 0, attrDatas.Count - 1 do
                                local attrData = attrDatas[i]
                                local attrId = attrData.attr
                                local value = attrData.value
                                GemAttribute = GemAttribute .. UIDefine.GetAttrDesStr(attrId, value)
                                if attrDatas.Count > 1 then
                                    if i == 0 then
                                        GemAttribute = GemAttribute .. "   "
                                    end
                                end
                            end
                            table.insert(gemInfo_attrs, GemAttribute)
                        end
                    end
                    table.insert(attrTables.gemInfo, gemInfo_attrs)
                end

                --套装属性
                if GlobalUtils.suitConfig then
                    local suitName = itemData:GetStrCustomAttr(GlobalUtils.suitConfig.Sign_STR)
                    if suitName ~= "" then
                        local config = GlobalUtils.suitConfig[suitName];
                        local num = 0;

                        local capacity = LD.GetBagCapacity(item_container_type.item_container_equip)
                        for i = 0, capacity - 1 do
                            local suitName2 = LD.GetItemStrCustomAttrByIndex(GlobalUtils.suitConfig.Sign_STR, i, item_container_type.item_container_equip)
                            if suitName2 == suitName then
                                num = num + 1;
                            end
                        end
                        table.insert(attrTables.suitInfo, "套装属性：" .. config.Suit_Name .. "(" .. num .. "/" .. config.Total .. ")")
                        local suitInfo_attrs = {}
                        for i = 1, config.Total do
                            if config.Size[i] then
                                local state = "(未激活)"
                                if num >= i then
                                    state = "(已激活)"
                                end
                                for j = 1, #config.Size[i].Attr do
                                    local attrDB = DB.GetOnceAttrByKey2(config.Size[i].Attr[j][1])
                                    if attrDB.Id ~= 0 then
                                        table.insert(suitInfo_attrs, "[" .. i .. "]" .. UIDefine.GetAttrDesStr(attrDB.Id, config.Size[i].Attr[j][2]) .. state)
                                    end

                                end
                            end
                        end
                        table.insert(attrTables.suitInfo, suitInfo_attrs)
                    end
                end

            end

            --属性表
            local itemAttrConfig = DB.GetOnceItem_AttByKey1(itemID)
            if itemAttrConfig ~= nil then
                --穿戴要求属性达到的值
                attrTables.attsRequire = { "", "", "", "" }
                local EquipNeedAtts = { itemAttrConfig.StrRequire, itemAttrConfig.IntRequire, itemAttrConfig.VitRequire, itemAttrConfig.AgiRequire }
                local EquipNeedName = { "力量需求", "灵性需求", "根骨需求", "敏捷需求" }
                for i = 1, 4 do
                    if EquipNeedAtts[i] ~= 0 then
                        attrTables.attsRequire[i] = EquipNeedName[i] .. "  " .. EquipNeedAtts[i]
                    end
                end
            end

        end
    end
    return attrTables
end
-- 当在输入框修改右边物品详情页面的选中数量时 需要调用此方法 更新选中的物品数量
function sui.UpdateSelectItemNum(numNow)
    if sui.SelectSellItemCountUI then
        local guid = GUI.GetGuid(sui.SelectSellItemCountUI)
        local itemGUID = GUI.GetData(sui.SelectSellItemCountUI, "guid")
        local price = GUI.GetData(sui.SelectSellItemCountUI, "price")
        local num = GUI.GetData(sui.SelectSellItemCountUI, "total")
        local id = tostring(GUI.GetData(sui.SelectSellItemCountUI, 'id'))
        if itemGUID ~= "0" then
            sui.OnCheckItem(guid, nil, num, price, itemGUID, numNow, id)
        end
    end
end

--
--	===============================================================================================================
--	 ----------------------------------------------------- 右边物品详情界面 ------------------------------------------
--	===============================================================================================================
--
function sui.ShowDetailInfo(infoTable, parent, typeIndex, _gt0)
    _gt = _gt0
    --初始化状态
    -- 创建物品信息界面
    sui.CreateBaseInfoNode(parent)
    -- 清空物品信息界面显示
    sui.ResetDetailArea()

    if infoTable == nil then
        return
    end

    --设置基础信息
    sui.SetBaseInfo(infoTable.name, infoTable.grade, infoTable.type, infoTable.level, infoTable.img, infoTable.bind)
    sui.itemMaxNum = infoTable.maxNum

    --设置滚动区域属性信息
    local scrollInfo = _gt.GetUI("detailScrollInfo")
    local item = _gt.GetUI("detailItem")
    local group = _gt.GetUI("detailGroup")
    local basePosY = 93
    local posY = 0
    local ScrollHeight = 282

    --可变基本属性
    if infoTable.job ~= nil then
        basePosY = basePosY + sui.AddSchool(item, basePosY, infoTable.job)
    end
    if infoTable.sex ~= nil and infoTable.sex ~= "" then
        basePosY = basePosY + sui.AddGender(item, basePosY, infoTable.sex)
    end
    basePosY = basePosY + sui.SetItemLinePositionY(item, basePosY)

    --样式二(出售页)：滚动属性
    if typeIndex == 2 then
        ScrollHeight = 350-- 405
        --posY = posY + sui.AddPrice(group, posY, infoTable.sellPrice)
        if infoTable.atts and #infoTable.atts > 0 then
            posY = posY + sui.AddBasicInfo(group, posY, infoTable.atts)
        end
        if infoTable.intensifyInfo and #infoTable.intensifyInfo > 0 then
            posY = posY + sui.AddIntensifyInfo(group, posY, infoTable.intensifyInfo)--强化信息
        end
        if infoTable.gemInfo and #infoTable.gemInfo > 0 then
            posY = posY + sui.AddGemInfo(group, posY, infoTable.gemInfo)--宝石信息
        end
        if infoTable.suitInfo and #infoTable.suitInfo > 0 then
            posY = posY + sui.AddSuitInfo(group, posY, infoTable.suitInfo)--套装信息
        end
        if infoTable.func ~= nil then
            posY = posY + sui.AddFunction(group, posY, infoTable.func)
        end
        posY = posY + sui.AddDesc(group, posY, infoTable.desc)
    end

    GUI.SetPositionY(scrollInfo, basePosY + 10)
    --local SizeY = ScrollHeight - basePosY
    --if SizeY < 10 then
    --    SizeY = 10
    --end
    --GUI.SetHeight(scrollInfo, SizeY + 10)
    posY = posY + 10
    GUI.SetHeight(group, posY)
    GUI.ScrollRectSetChildSize(scrollInfo, Vector2.New(315, posY))
end

--是否全部为空
function sui.IsEmpptyStrTable(strs)
    if strs ~= nil then
        local count = #strs
        for i = 1, count do
            if strs[i] ~= nil and strs[i] ~= "" then
                return false
            end
        end
    end
    return true
end

function sui.PackPetBaseInfo(petName)
    local attrTables = {}
    local config = DB.GetOncePetByKey2(petName)
    if config ~= nil then
        attrTables.name = config.Name
        attrTables.itemType = config.Type
        attrTables.type = UIDefine.PetTypeTxt[config.Type]
        attrTables.level = 1
        attrTables.img = tostring(config.Head)
        attrTables.grade = config.Type
        attrTables.sellPrice = 0
        attrTables.desc = config.Info
        attrTables.buyPrice = 0
        --attrTables.func = config.Info
        attrTables.atts = {}
        attrTables.equipTurnBorn = 0
        attrTables.equipLevel = 0
        attrTables.role = 0

        attrTables.job = nil
        attrTables.sex = ""
    end
    return attrTables
end

function sui.PackItemBaseInfo(itemID)
    local attrTables = {}
    local itemConfig = DB.GetOnceItemByKey1(itemID)
    if itemConfig ~= nil then
        attrTables.name = itemConfig.Name
        attrTables.itemType = itemConfig.Type
        attrTables.type = itemConfig.ShowType
        attrTables.level = itemConfig.Level
        attrTables.img = itemConfig.Icon
        attrTables.grade = itemConfig.Grade
        attrTables.sellPrice = itemConfig.SaleGoldBind
        attrTables.desc = itemConfig.Tips
        attrTables.buyPrice = itemConfig.BuyGoldBind
        attrTables.func = itemConfig.Info
        attrTables.atts = {}--基础属性、特效特技
        attrTables.intensifyInfo = {} --强化属性
        attrTables.gemInfo = {}--宝石属性
        attrTables.suitInfo = {}--套装属性
        attrTables.equipTurnBorn = 0
        attrTables.equipLevel = 0
        attrTables.role = 0

        attrTables.job = nil
        if itemConfig.Job ~= 0 then
            local schoolConfig = DB.GetSchool(itemConfig.Job)
            if schoolConfig ~= nil then
                attrTables.job = schoolConfig.Name
            end
        end
        attrTables.sex = UIDefine.GetSexName(itemConfig.Sex)
    end
    return attrTables
end

function sui.PackShopPetInfos(petName)
    local attrTables = sui.PackPetBaseInfo(petName)
    return attrTables
end

function sui.PackShopItemInfos(itemID, bind)
    local attrTables = sui.PackItemBaseInfo(itemID)
    local itemConfig = DB.GetOnceItemByKey1(itemID)
    if itemConfig ~= nil then
        local itemType = itemConfig.Type
        attrTables.bind = bind
        --装备分类
        if itemType == 1 then
            attrTables.func = nil
            attrTables.equipTurnBorn = itemConfig.TurnBorn
            attrTables.equipLevel = itemConfig.Level
            if itemConfig.Role2 ~= 0 then
                attrTables.role = tostring(itemConfig.Role) .. "," .. tostring(itemConfig.Role2)
            else
                attrTables.role = itemConfig.Role
            end
            --属性表
            local itemAttrConfig = DB.GetOnceItem_AttByKey1(itemID)
            if itemAttrConfig ~= nil then
                --装备属性值
                local count = 0
                local ItemAttConfigAtts = { itemAttrConfig.Att1, itemAttrConfig.Att2, itemAttrConfig.Att3, itemAttrConfig.Att4, itemAttrConfig.Att5 }
                local ItemAttConfigAttsMin = { itemAttrConfig.Att1Min, itemAttrConfig.Att2Min, itemAttrConfig.Att3Min, itemAttrConfig.Att4Min, itemAttrConfig.Att5Min }
                local ItemAttConfigAttsMax = { itemAttrConfig.Att1Max, itemAttrConfig.Att2Max, itemAttrConfig.Att3Max, itemAttrConfig.Att4Max, itemAttrConfig.Att5Max }
                for i = 1, 5 do
                    if ItemAttConfigAtts[i] ~= 0 then
                        local AttrConfig = DB.GetOnceAttrByKey1(ItemAttConfigAtts[i])
                        if AttrConfig ~= nil then
                            count = count + 1
                            local attDesc = AttrConfig.ChinaName .. "  "
                            if AttrConfig.IsPct == 1 then
                                attDesc = attDesc .. (ItemAttConfigAttsMin[i] / 100) .. "%~" .. (ItemAttConfigAttsMax[i] / 100) .. "%"
                            else
                                attDesc = attDesc .. ItemAttConfigAttsMin[i] .. "~" .. ItemAttConfigAttsMax[i]
                            end

                            attrTables.atts[count] = attDesc
                        end
                    end
                end
                --穿戴要求属性达到的值
                attrTables.attsRequire = { "", "", "", "" }
                local EquipNeedAtts = { itemAttrConfig.StrRequire, itemAttrConfig.IntRequire, itemAttrConfig.VitRequire, itemAttrConfig.AgiRequire }
                local SelfAtts = { RoleAttr.RoleAttrStr, RoleAttr.RoleAttrInt, RoleAttr.RoleAttrVit, RoleAttr.RoleAttrAgi }
                local EquipNeedName = { "力量需求", "灵性需求", "根骨需求", "敏捷需求" }
                for i = 1, 4 do
                    if EquipNeedAtts[i] ~= 0 then
                        local selfVal = CL.GetIntAttr(SelfAtts[i])
                        local bMatch = selfVal >= EquipNeedAtts[i] and true or false
                        attrTables.attsRequire[i] = bMatch and EquipNeedName[i] .. "  " .. EquipNeedAtts[i] or "<color=red>" .. EquipNeedName[i] .. "  " .. EquipNeedAtts[i] .. "</color>"
                    end
                end
            end
        end
    end

    return attrTables
end

function sui.SetBaseInfo(name, grade, type, level, img, bind)
    local icon = _gt.GetUI("detailicon")
    if icon ~= nil then
        GUI.ImageSetImageID(icon, img)
    end
    local item = _gt.GetUI("detailItem")
    if item ~= nil then
        GUI.ItemCtrlSetElementValue(item, eItemIconElement.Border, UIDefine.ItemIconBg[grade]);
        GUI.SetVisible(item, true)
    end

    local nameL = _gt.GetUI("detailname")
    if nameL ~= nil then
        GUI.StaticSetText(nameL, name)
    end
    local typeVal = _gt.GetUI("detailtypeVal")
    if typeVal ~= nil then
        GUI.StaticSetText(typeVal, type)
    end
    local levelVal = _gt.GetUI("detaillevelVal")
    if levelVal ~= nil then
        GUI.StaticSetText(levelVal, level)
    end
    local detailBindFlag = _gt.GetUI("detailBindFlag")
    if detailBindFlag ~= nil then
        GUI.SetVisible(detailBindFlag, bind)
    end
end

function sui.ResetDetailArea()
    local item = _gt.GetUI("detailItem")
    if item ~= nil then
        GUI.SetVisible(item, false)
    end
    local school = _gt.GetUI("school")
    if school ~= nil then
        GUI.SetVisible(school, false)
    end
    local gender = _gt.GetUI("gender")
    if gender ~= nil then
        GUI.SetVisible(gender, false)
    end
    local limit = _gt.GetUI("limit")
    if limit ~= nil then
        GUI.SetVisible(limit, false)
    end
    local equipLimit = _gt.GetUI("equipLimit")
    if equipLimit ~= nil then
        GUI.SetVisible(equipLimit, false)
    end
    local basic = _gt.GetUI("basic")
    if basic ~= nil then
        GUI.SetVisible(basic, false)
    end
    local intensify = _gt.GetUI("intensify")
    if intensify ~= nil then
        GUI.SetVisible(intensify, false)
    end
    local gem = _gt.GetUI("gem")
    if gem ~= nil then
        GUI.SetVisible(gem, false)
    end
    local suit = _gt.GetUI("suit")
    if suit ~= nil then
        GUI.SetVisible(suit, false)
    end
    local durability = _gt.GetUI("durability")
    if durability ~= nil then
        GUI.SetVisible(durability, false)
    end
    local price = _gt.GetUI("price")
    if price ~= nil then
        GUI.SetVisible(price, false)
    end
    local desc = _gt.GetUI("desc")
    if desc ~= nil then
        GUI.SetVisible(desc, false)
    end
    local func = _gt.GetUI("func")
    if func ~= nil then
        GUI.SetVisible(func, false)
    end
    local buyNum = _gt.GetUI("buyNum")
    if buyNum ~= nil then
        GUI.SetVisible(buyNum, false)
    end
    local spendCount = _gt.GetUI("spendCount")
    if spendCount then
        GUI.StaticSetText(spendCount, "0")
    end
    local num_group = _gt.GetUI('num_group')
    if num_group ~= nil then
        GUI.SetVisible(num_group, false)
    end
end

function sui.CreateBaseInfoNode(parent)
    local detailNode = _gt.GetUI("detailNode")
    if detailNode == nil then
        detailNode = GUI.GroupCreate(parent, "detailNode", 0, 0, GUI.GetWidth(parent), GUI.GetHeight(parent))
        _gt.BindName(detailNode, "detailNode")
        UILayout.SetSameAnchorAndPivot(detailNode, UILayout.TopLeft)

        local spacing_x = 20

        --顶部统一物品栏
        local item = GUI.ItemCtrlCreate(detailNode, "detailItem", "1800400050", spacing_x, 15)
        _gt.BindName(item, "detailItem")
        --物品图标背景\图标\绑定标记
        local pic = GUI.ImageCreate(item, "detailpic", "1800400060", 0, 0, false, 80, 80)
        local icon = GUI.ImageCreate(item, "detailicon", "1900107020", 6, 6, false, 68, 68)
        _gt.BindName(icon, "detailicon")
        local bindFlag = GUI.ImageCreate(item, "detailBindFlag", "1800707120", 2, 0)
        _gt.BindName(bindFlag, "detailBindFlag")
        GUI.SetAnchor(bindFlag, UIAnchor.TopLeft)

        local name = GUI.CreateStatic(item, "detailname", "50级烈云", 95, 0, 225, 30)
        _gt.BindName(name, "detailname")
        UILayout.StaticSetFontSizeColorAlignment(name, UIDefine.FontSizeL, UIDefine.BrownColor, nil)

        local type = GUI.CreateStatic(item, "detailtype", "类型：", 95, 31, 100, 30)
        _gt.BindName(type, "detailtype")
        UILayout.StaticSetFontSizeColorAlignment(type, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        local typeVal = GUI.CreateStatic(type, "detailtypeVal", "无级别", 66, 0, 150, 30)
        _gt.BindName(typeVal, "detailtypeVal")
        UILayout.StaticSetFontSizeColorAlignment(typeVal, UIDefine.FontSizeL, UIDefine.Yellow2Color, nil)

        local level = GUI.CreateStatic(item, "detaillevel", "等级：", 95, 62, 100, 30)
        _gt.BindName(level, "detaillevel")
        UILayout.StaticSetFontSizeColorAlignment(level, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        local levelVal = GUI.CreateStatic(level, "detaillevelVal", "0", 66, 0, 100, 30)
        _gt.BindName(levelVal, "detaillevelVal")
        UILayout.StaticSetFontSizeColorAlignment(levelVal, UIDefine.FontSizeL, UIDefine.Yellow2Color, nil)

        --滚动区大小 192与315
        local scrollInfo = GUI.ScrollRectCreate(detailNode, "detailScrollInfo", spacing_x, 110, 325, 245, 0, false, Vector2.New(325, 245), UIAroundPivot.Top, UIAnchor.Top)
        _gt.BindName(scrollInfo, "detailScrollInfo")
        local group = GUI.GroupCreate(scrollInfo, "detailGroup", 0, 0, 315, 1)
        _gt.BindName(group, "detailGroup")

        -- 选中物品数量部分
        local num_group = GUI.GroupCreate(detailNode, 'num_group', 0, -10, GUI.GetWidth(detailNode) - spacing_x - 10, 50)
        UILayout.SetSameAnchorAndPivot(num_group, UILayout.Bottom)
        _gt.BindName(num_group, 'num_group')

        local numNode = GUI.CreateStatic(num_group, "numNode", "数量", 0, 0, 100, 30)
        _gt.BindName(numNode, "SellNumNode")
        UILayout.SetSameAnchorAndPivot(numNode, UILayout.Left)
        UILayout.StaticSetFontSizeColorAlignment(numNode, UIDefine.FontSizeL, UIDefine.BrownColor, TextAnchor.MiddleLeft)

        local minusBtn = GUI.ButtonCreate(num_group, "SellMinusBtn", "1800402140", 65, 0, Transition.ColorTint, "")
        _gt.BindName(minusBtn, "SellMinusBtn")
        UILayout.SetSameAnchorAndPivot(minusBtn, UILayout.Left)
        GUI.RegisterUIEvent(minusBtn, UCE.PointerClick, m.script_name, sui.script_name .. "OnSellMinusBtnClick")
        minusBtn:RegisterEvent(UCE.PointerUp)
        minusBtn:RegisterEvent(UCE.PointerDown)
        GUI.RegisterUIEvent(minusBtn, UCE.PointerDown, m.script_name, sui.script_name .. "on_sell_minus_btn_down")
        GUI.RegisterUIEvent(minusBtn, UCE.PointerUp, m.script_name, sui.script_name .. "on_sell_minus_btn_up")

        local plusBtn = GUI.ButtonCreate(num_group, "SellPlusBtn", "1800402150", -25, 0, Transition.ColorTint, "")
        _gt.BindName(plusBtn, "SellPlusBtn")
        UILayout.SetSameAnchorAndPivot(plusBtn, UILayout.Right)
        GUI.RegisterUIEvent(plusBtn, UCE.PointerClick, m.script_name, sui.script_name .. "OnSellPlusBtnClick")
        plusBtn:RegisterEvent(UCE.PointerUp)
        plusBtn:RegisterEvent(UCE.PointerDown)
        GUI.RegisterUIEvent(plusBtn, UCE.PointerDown, m.script_name, sui.script_name .. "on_sell_plus_btn_down")
        GUI.RegisterUIEvent(plusBtn, UCE.PointerUp, m.script_name, sui.script_name .. "on_sell_plus_btn_up")

        local countEdit = GUI.EditCreate(num_group, "SellCountEdit", "1800400390", "", 20, 0, Transition.ColorTint, "system", 0, 0, 30, 8, InputType.Standard, ContentType.IntegerNumber)
        _gt.BindName(countEdit, "SellCountEdit")
        UILayout.SetSameAnchorAndPivot(countEdit, UILayout.Center)
        GUI.EditSetFontSize(countEdit, UIDefine.FontSizeM)
        GUI.EditSetTextColor(countEdit, UIDefine.BrownColor)
        GUI.EditSetTextM(countEdit, "1")
        GUI.RegisterUIEvent(countEdit, UCE.EndEdit, m.script_name, sui.script_name .. "OnSellCountModify")

        --local extNode = GUI.GroupCreate(detailNode, "extNode", 208, 148, 0, 0)
        --_gt.BindName(extNode, "detailExtNode")
        --UILayout.SetSameAnchorAndPivot(extNode, UILayout.Center)
    end
end

function sui.OnSellCountModify(guid)
    local SellCountEdit = _gt.GetUI("SellCountEdit")
    if SellCountEdit then
        local count = tonumber(GUI.EditGetTextM(SellCountEdit))
        sui.OnChangeItemNum(count)
    end
end
sui.on_sell_plus_btn_fun = function()
    sui.PressedCounter = sui.PressedCounter + 1
    if sui.PressedCounter >= sui.PRESS_WAIT_TIME then
        local plusBtn = _gt.GetUI('SellPlusBtn')
        sui.OnSellPlusBtnClick(GUI.GetGuid(plusBtn))
    end
end
sui.on_sell_plus_btn_down = function()
    sui.PressedCounter = 0
    if sui.on_sell_plus_btn_timer == nil then
        sui.on_sell_plus_btn_timer = Timer.New(sui.on_sell_plus_btn_fun, 0.1, -1)
    end
    sui.on_sell_plus_btn_timer:Start()
end

sui.on_sell_plus_btn_up = function()
    if sui.on_sell_plus_btn_timer then
        sui.on_sell_plus_btn_timer:Stop()
        sui.on_sell_plus_btn_timer = nil
    end
end

-- 右边详情页面 数量+ 按钮点击事件
function sui.OnSellPlusBtnClick(guid)
    sui.OnSellItemClick(sui.PressedItemGuid)
end

-- 套进减少按钮方法 让定时器能执行
sui.on_pressed_minus_btn_fun = function()
    sui.PressedCounter = sui.PressedCounter + 1
    if sui.PressedCounter >= sui.PRESS_WAIT_TIME then
        local minusBtn = _gt.GetUI("SellMinusBtn")
        sui.OnSellMinusBtnClick(GUI.GetGuid(minusBtn))
    end
end
-- 长按减少 按下
sui.on_sell_minus_btn_down = function()
    sui.PressedCounter = 0
    if sui.sell_minus_btn_timer == nil then
        sui.sell_minus_btn_timer = Timer.New(sui.on_pressed_minus_btn_fun, 0.1, -1)
    end
    sui.sell_minus_btn_timer:Start()
end
-- 长按减少 弹起
sui.on_sell_minus_btn_up = function()
    if sui.sell_minus_btn_timer then
        sui.sell_minus_btn_timer:Stop()
        sui.sell_minus_btn_timer = nil
    end
end
-- 物品详情页面减少按钮事件
function sui.OnSellMinusBtnClick(guid)
    sui.OnClickMinusBtn(sui.PressedItemGuid)
end

function sui.OnChangeItemNum(count)
    if count == nil then
        count = 0
    end
    local SellCountEdit = _gt.GetUI("SellCountEdit")
    if SellCountEdit then
        count = math.max(0, count)
        count = math.min(sui.itemMaxNum, count)
        GUI.EditSetTextM(SellCountEdit, tostring(count))
        if sui.numNodify ~= nil then
            sui.numNodify(count)
        end
    end
end

function sui.AddSchool(parent, posY, schoolInfo)
    local school = _gt.GetUI("school")
    local schoolVal = _gt.GetUI("schoolVal")
    if school == nil or schoolVal == nil then
        school = GUI.CreateStatic(parent, "school", "门派：", 95, posY, 100, 30)
        _gt.BindName(school, "school")
        UILayout.StaticSetFontSizeColorAlignment(school, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        schoolVal = GUI.CreateStatic(school, "schoolVal", "无限制", 66, 0, 150, 30)
        _gt.BindName(schoolVal, "schoolVal")
        UILayout.StaticSetFontSizeColorAlignment(schoolVal, UIDefine.FontSizeL, UIDefine.Yellow2Color, nil)
    end
    GUI.SetVisible(school, true)
    GUI.SetPositionY(school, posY)

    if schoolVal ~= nil then
        GUI.StaticSetText(schoolVal, schoolInfo)
    end
    return 31
end

function sui.AddGender(parent, posY, genderInfo)
    local gender = _gt.GetUI("gender")
    local genderVal = _gt.GetUI("genderVal")
    if gender == nil or genderVal == nil then
        gender = GUI.CreateStatic(parent, "gender", "性别：", 95, posY, 100, 30)
        _gt.BindName(gender, "gender")
        UILayout.StaticSetFontSizeColorAlignment(gender, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        genderVal = GUI.CreateStatic(gender, "genderVal", "女", 66, 0, 150, 30)
        _gt.BindName(genderVal, "genderVal")
        UILayout.StaticSetFontSizeColorAlignment(genderVal, UIDefine.FontSizeL, UIDefine.Yellow2Color, nil)
    end
    GUI.SetVisible(gender, true)
    GUI.SetPositionY(gender, posY)

    if genderVal ~= nil then
        GUI.StaticSetText(genderVal, genderInfo)
    end
    return 31
end

function sui.AddLimit(parent, posY, limitInfo)
    local limit = _gt.GetUI("limit")
    if limit == nil then
        limit = GUI.CreateStatic(parent, "limit", "穿着限制：嫡剑仙 阎魔令", 5, posY, 400, 30)
        _gt.BindName(limit, "limit")
        UILayout.StaticSetFontSizeColorAlignment(limit, UIDefine.FontSizeL, UIDefine.RedColor, nil)
    end
    GUI.SetVisible(limit, true)
    GUI.SetPositionY(limit, posY)

    GUI.StaticSetText(limit, limitInfo)
    return 31
end

function sui.SetItemLinePositionY(parent, posY)
    local line = _gt.GetUI("detailLine")
    if line == nil then
        line = GUI.ImageCreate(parent, "detailLine", "1800600030", 0, posY)
        _gt.BindName(line, "detailLine")
    else
        GUI.SetPositionY(line, posY)
    end

    return 6
end

function sui.AddEquipLimit(parent, posY, TurnBorn, Level, Role, attsRequire)
    local equipLimit = _gt.GetUI("equipLimit")
    if equipLimit == nil then
        --穿戴限制
        equipLimit = GUI.ImageCreate(parent, "equipLimit", "1801100040", 5, posY)
        _gt.BindName(equipLimit, "equipLimit")
        local title = GUI.CreateStatic(equipLimit, "title", "穿戴需求", 0, 0, 200, 30)
        UILayout.StaticSetFontSizeColorAlignment(title, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        for i = 0, 5 do
            local basicVal = GUI.CreateStatic(equipLimit, "val" .. i, "穿戴等级：100", 48, (33 * (i + 1)), 300, 30, "system", true)
            _gt.BindName(basicVal, "val" .. i)
            UILayout.StaticSetFontSizeColorAlignment(basicVal, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        end
        GUI.ImageCreate(equipLimit, "line", "1800600030", 0, 104)
    end
    GUI.SetVisible(equipLimit, true)
    GUI.SetPositionY(equipLimit, posY)

    for i = 0, 5 do
        local basicVal = _gt.GetUI("val" .. i)
        if basicVal ~= nil then
            GUI.SetVisible(basicVal, false)
        end
    end
    local attCount = 0
    local infos = {}
    local levelNeedInfo = "穿戴等级  "
    if TurnBorn ~= nil and TurnBorn ~= 0 or Level ~= nil and Level ~= 0 then
        if TurnBorn ~= nil and TurnBorn ~= 0 then
            levelNeedInfo = levelNeedInfo .. tostring(TurnBorn) .. "转"
        end
        if Level ~= nil and Level ~= 0 then
            levelNeedInfo = levelNeedInfo .. tostring(Level) .. "级"
        end
        local selfRein = CL.GetIntAttr(RoleAttr.RoleAttrReincarnation)
        local selfLevel = CL.GetIntAttr(RoleAttr.RoleAttrLevel)
        local bMatch = false
        if selfRein > TurnBorn or selfRein == TurnBorn and selfLevel >= Level then
            bMatch = true
        end
        table.insert(infos, bMatch and levelNeedInfo or "<color=red>" .. levelNeedInfo .. "</color>")
        attCount = attCount + 1
    end
    for i = 1, 4 do
        if attsRequire ~= nil and attsRequire[i] ~= "" then
            table.insert(infos, attsRequire[i])
            attCount = attCount + 1
        end
    end
    if Role ~= nil and Role ~= 0 then
        local selfRole = CL.GetIntAttr(RoleAttr.RoleAttrRole)
        if type(Role) == "number" then
            local bMatch = selfRole == Role and true or false
            table.insert(infos, bMatch and "所需角色  " .. UIDefine.GetRoleRace(Role) or "<color=red>所需角色  " .. UIDefine.GetRoleRace(Role) .. "</color>")
        elseif type(Role) == "string" then
            Val = string.split(Role, ",")
            local role1 = tonumber(Val[1])
            local role2 = tonumber(Val[2])
            local RoleName1 = DB.GetRole(role1).RoleName
            local RoleName2 = DB.GetRole(role2).RoleName
            local bMatch = selfRole == role1 and true or false
            if bMatch then
                table.insert(infos, bMatch and "所需角色  " .. RoleName1 .. " " .. RoleName2)
            else
                bMatch = selfRole == role2 and true or false
                table.insert(infos, bMatch and "所需角色  " .. RoleName1 .. "" .. RoleName2 or "<color=red>所需角色  " .. RoleName1 .. " " .. RoleName2 .. "</color>")
            end
        end
        attCount = attCount + 1
    end

    for i = 0, attCount - 1 do
        local basicVal = _gt.GetUI("val" .. i)
        if basicVal ~= nil then
            GUI.SetVisible(basicVal, true)
            GUI.StaticSetText(basicVal, infos[i + 1])
        end
    end
    local line = GUI.GetChild(equipLimit, "line")
    GUI.SetPositionY(line, (attCount + 1) * 33)

    return 49 + attCount * 33
end

--套装属性
function sui.AddSuitInfo(parent, posY, suitAttrs)
    local attsT = suitAttrs[2]

    local DefaultAttsCount = 20
    local suit = _gt.GetUI("suit")
    if suit == nil then
        --基础属性
        suit = GUI.ImageCreate(parent, "suit", "1801100040", 5, posY)
        _gt.BindName(suit, "suit")
        local title = GUI.CreateStatic(suit, "title", suitAttrs[1], 0, 0, 200, 30)
        UILayout.StaticSetFontSizeColorAlignment(title, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        for i = 0, DefaultAttsCount do
            local suitVal = GUI.CreateStatic(suit, "suitVal" .. i, "", 48, (33 * (i + 1)), 300, 30)
            _gt.BindName(suitVal, "suitVal" .. i)
            UILayout.StaticSetFontSizeColorAlignment(suitVal, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        end
        GUI.ImageCreate(suit, "line", "1800600030", 0, 104)
    end
    GUI.SetVisible(suit, true)
    GUI.SetPositionY(suit, posY)

    for i = 0, DefaultAttsCount do
        local suitVal = _gt.GetUI("suitVal" .. i)
        if suitVal ~= nil then
            GUI.SetVisible(suitVal, false)
        end
    end

    local attCount = 1
    if suitAttrs[2] ~= nil then
        attCount = #suitAttrs[2]
    end
    for i = 0, attCount - 1 do
        local suitVal = _gt.GetUI("suitVal" .. i)
        if suitVal ~= nil then
            GUI.SetVisible(suitVal, true)
            GUI.StaticSetText(suitVal, suitAttrs[2][i + 1])
        end
    end

    local line = GUI.GetChild(suit, "line")
    GUI.SetPositionY(line, (attCount + 1) * 33)

    return 49 + attCount * 33
end

--宝石属性
function sui.AddGemInfo(parent, posY, gemAttrs)
    local attsT = gemAttrs[2]

    local DefaultAttsCount = 20
    local gem = _gt.GetUI("gem")
    if gem == nil then
        --基础属性
        gem = GUI.ImageCreate(parent, "gem", "1801100040", 5, posY)
        _gt.BindName(gem, "gem")
        local title = GUI.CreateStatic(gem, "title", gemAttrs[1], 0, 0, 200, 30)
        UILayout.StaticSetFontSizeColorAlignment(title, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        for i = 0, DefaultAttsCount do
            local gemVal = GUI.CreateStatic(gem, "gemVal" .. i, "", 48, (33 * (i + 1)), 300, 30)
            _gt.BindName(gemVal, "gemVal" .. i)
            UILayout.StaticSetFontSizeColorAlignment(gemVal, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        end
        GUI.ImageCreate(gem, "line", "1800600030", 0, 104)
    end
    GUI.SetVisible(gem, true)
    GUI.SetPositionY(gem, posY)

    for i = 0, DefaultAttsCount do
        local gemVal = _gt.GetUI("gemVal" .. i)
        if gemVal ~= nil then
            GUI.SetVisible(gemVal, false)
        end
    end

    local attCount = 1
    if gemAttrs[2] ~= nil then
        attCount = #gemAttrs[2]
    end
    for i = 0, attCount - 1 do
        local gemVal = _gt.GetUI("gemVal" .. i)
        if gemVal ~= nil then
            GUI.SetVisible(gemVal, true)
            GUI.StaticSetText(gemVal, gemAttrs[2][i + 1])
        end
    end

    local line = GUI.GetChild(gem, "line")
    GUI.SetPositionY(line, (attCount + 1) * 33)

    return 49 + attCount * 33
end


--强化属性
function sui.AddIntensifyInfo(parent, posY, intensifyAtts)
    local attsT = intensifyAtts[2]

    local DefaultAttsCount = 20
    local intensify = _gt.GetUI("intensify")
    if intensify == nil then
        --基础属性
        intensify = GUI.ImageCreate(parent, "intensify", "1801100040", 5, posY)
        _gt.BindName(intensify, "intensify")
        local title = GUI.CreateStatic(intensify, "title", intensifyAtts[1], 0, 0, 200, 30)
        UILayout.StaticSetFontSizeColorAlignment(title, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        for i = 0, DefaultAttsCount do
            local intensifyVal = GUI.CreateStatic(intensify, "intensifyVal" .. i, "", 48, (33 * (i + 1)), 300, 30)
            _gt.BindName(intensifyVal, "intensifyVal" .. i)
            UILayout.StaticSetFontSizeColorAlignment(intensifyVal, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        end
        GUI.ImageCreate(intensify, "line", "1800600030", 0, 104)
    end
    GUI.SetVisible(intensify, true)
    GUI.SetPositionY(intensify, posY)

    for i = 0, DefaultAttsCount do
        local intensifyVal = _gt.GetUI("intensifyVal" .. i)
        if intensifyVal ~= nil then
            GUI.SetVisible(intensifyVal, false)
        end
    end

    local attCount = 1
    if intensifyAtts[2] ~= nil then
        attCount = #intensifyAtts[2]
    end
    for i = 0, attCount - 1 do
        local intensifyVal = _gt.GetUI("intensifyVal" .. i)
        if intensifyVal ~= nil then
            GUI.SetVisible(intensifyVal, true)
            GUI.StaticSetText(intensifyVal, intensifyAtts[2][i + 1])
        end
    end

    local line = GUI.GetChild(intensify, "line")
    GUI.SetPositionY(line, (attCount + 1) * 33)

    return 49 + attCount * 33
end

--基础属性
function sui.AddBasicInfo(parent, posY, basicAtts)
    local DefaultAttsCount = 20
    local basic = _gt.GetUI("basic")
    if basic == nil then
        --基础属性
        basic = GUI.ImageCreate(parent, "basic", "1801100040", 5, posY)
        _gt.BindName(basic, "basic")
        local title = GUI.CreateStatic(basic, "title", "基础属性", 0, 0, 200, 30)
        UILayout.StaticSetFontSizeColorAlignment(title, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        for i = 0, DefaultAttsCount do
            local basicVal = GUI.CreateStatic(basic, "basicVal" .. i, "物理攻击：100", 48, (33 * (i + 1)), 300, 30)
            _gt.BindName(basicVal, "basicVal" .. i)
            UILayout.StaticSetFontSizeColorAlignment(basicVal, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        end
        GUI.ImageCreate(basic, "line", "1800600030", 0, 104)
    end
    GUI.SetVisible(basic, true)
    GUI.SetPositionY(basic, posY)

    for i = 0, DefaultAttsCount do
        local basicVal = _gt.GetUI("basicVal" .. i)
        if basicVal ~= nil then
            GUI.SetVisible(basicVal, false)
        end
    end
    local attCount = 1
    if basicAtts ~= nil then
        attCount = #basicAtts
    end

    for i = 0, attCount - 1 do
        local basicVal = _gt.GetUI("basicVal" .. i)
        if basicVal ~= nil then
            GUI.SetVisible(basicVal, true)
            print("basicAtts =>" .. basicAtts[i + 1])
            GUI.StaticSetText(basicVal, basicAtts[i + 1])
        end
    end

    local line = GUI.GetChild(basic, "line")
    GUI.SetPositionY(line, (attCount + 1) * 33)

    return 49 + attCount * 33
end

--耐久度
function sui.AddDurability(parent, posY, durabilityInfo)
    local durability = _gt.GetUI("durability")
    if durability == nil then
        --耐久度
        durability = GUI.CreateStatic(parent, "durability", "耐久度：100/201", 5, posY, 200, 30)
        _gt.BindName(durability, "durability")
        UILayout.StaticSetFontSizeColorAlignment(durability, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
    end
    GUI.SetVisible(durability, true)
    GUI.SetPositionY(durability, posY)

    GUI.StaticSetText(durability, durabilityInfo)
    return 33
end

--购买数量
function sui.AddBuyNum(parent, posY, buyNumInfo)
    local buyNum = _gt.GetUI("buyNum")
    if buyNum == nil then
        --购买数量
        buyNum = GUI.CreateStatic(parent, "buyNum", "", 5, posY, 200, 30)
        _gt.BindName(buyNum, "buyNum")
        UILayout.StaticSetFontSizeColorAlignment(buyNum, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        GUI.ImageCreate(buyNum, "line", "1800600030", 0, 34)
    end
    GUI.SetVisible(buyNum, true)
    GUI.SetPositionY(buyNum, posY)

    GUI.StaticSetText(buyNum, buyNumInfo)

    local line = GUI.GetChild(buyNum, "line")
    if line ~= nil then
        GUI.SetPositionY(line, 34)
    end
    return 43
end

--出售价
function sui.AddPrice(parent, posY, priceInfo)
    local price = _gt.GetUI("price")
    local priceVal = _gt.GetUI("priceVal")
    if price == nil or priceVal == nil then
        --售价
        price = GUI.CreateStatic(parent, "price", "出售价：", 5, posY, 200, 30)
        _gt.BindName(price, "price")
        UILayout.StaticSetFontSizeColorAlignment(price, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        GUI.ImageCreate(price, "icon", UIDefine.AttrIcon[RoleAttr.RoleAttrBindGold], 96, -3, false, 35, 35)
        priceVal = GUI.CreateStatic(price, "priceVal", "10", 130, 0, 200, 30)
        _gt.BindName(priceVal, "priceVal")
        UILayout.StaticSetFontSizeColorAlignment(priceVal, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        GUI.ImageCreate(price, "line", "1800600030", 0, 36)
    end
    GUI.SetVisible(price, true)
    GUI.SetPositionY(price, posY)
    if priceVal ~= nil then
        GUI.StaticSetText(priceVal, priceInfo)
    end
    return 48
end

--商品描述
function sui.AddDesc(parent, posY, descInfo)
    local desc = _gt.GetUI("desc")
    if desc == nil then
        --商品描述
        desc = GUI.RichEditCreate(parent, "desc", "", 5, posY, 300, 22)
        _gt.BindName(desc, "desc")
        UILayout.StaticSetFontSizeColorAlignment(desc, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
    end
    GUI.SetVisible(desc, true)
    GUI.SetPositionY(desc, posY)

    GUI.StaticSetText(desc, descInfo)
    local height = GUI.RichEditGetPreferredHeight(desc)
    GUI.SetHeight(desc, height)
    return height + 11
end

--物品效用
function sui.AddFunction(parent, posY, funcInfo)
    local func = _gt.GetUI("func")
    if func == nil then
        --物品效用
        func = GUI.RichEditCreate(parent, "func", "", 5, posY, 300, 22)
        _gt.BindName(func, "func")
        UILayout.StaticSetFontSizeColorAlignment(func, UIDefine.FontSizeL, UIDefine.BrownColor, nil)
        GUI.ImageCreate(func, "line", "1800600030", 0, 36)
    end
    GUI.SetVisible(func, true)
    GUI.SetPositionY(func, posY)

    funcInfo = "效用:\n" .. funcInfo
    GUI.StaticSetText(func, funcInfo)
    local height = GUI.RichEditGetPreferredHeight(func)
    GUI.SetHeight(func, height)

    local line = GUI.GetChild(func, "line")
    if line ~= nil then
        GUI.SetPositionY(line, height + 5)
    end
    return height + 16
end

--
--	===============================================================================================================
--	 ----------------------------------------------------- 筛选界面 ------------------------------------------
--	===============================================================================================================
--

-- 创建出售筛选页面
function sui.CreateSaleScreeningPanel(SaleScreeningPanelBg)
    local topText = GUI.CreateStatic(SaleScreeningPanelBg, "topText", "请选择要筛选的道具类型", 0, 85, 300, 30)
    UILayout.StaticSetFontSizeColorAlignment(topText, UIDefine.FontSizeS, UIDefine.RedColor, TextAnchor.UpperCenter)
    GUI.SetAnchor(topText, UIAnchor.Top)

    local screeningBg = GUI.ImageCreate(SaleScreeningPanelBg, "screeningBg", "1800400200", 0, -35, false, 560, 130)
    GUI.SetAnchor(screeningBg, UIAnchor.Center)
    GUI.SetPivot(screeningBg, UIAroundPivot.Center)

    local screeningList = GUI.LoopScrollRectCreate(
            screeningBg,
            "screeningList",
            0,
            7,
            550,
            130,
            m.script_name,
            sui.script_name .. "CreateScreeningList",
            m.script_name,
            sui.script_name .. "RefreshScreeningList",
            0,
            true,
            Vector2.New(90, 90),
            1,
            UIAroundPivot.Top,
            UIAnchor.Top,
            false
    )
    _gt.BindName(screeningList, "screeningList")
    GUI.SetAnchor(screeningList, UIAnchor.Top)
    GUI.SetPivot(screeningList, UIAroundPivot.Top)
    GUI.ScrollRectSetChildSpacing(screeningList, Vector2.New(15, 0))

    GUI.LoopScrollRectSetTotalCount(screeningList, #sui.SelectList)
    GUI.LoopScrollRectRefreshCells(screeningList)

    local midText = GUI.CreateStatic(SaleScreeningPanelBg, "midText", "请选择要筛选的道具品质", 0, 260, 300, 30)
    UILayout.StaticSetFontSizeColorAlignment(midText, UIDefine.FontSizeS, UIDefine.RedColor, TextAnchor.UpperCenter)
    GUI.SetAnchor(midText, UIAnchor.Top)

    for i = 1, #sui.QualityList do

        -- 第一个默认选中
        local ff = false
        if i == 1 then
            ff = true
        end

        local qualityIcon = GUI.CheckBoxCreate(SaleScreeningPanelBg, "qualityIcon" .. i, "1800607150", "1800607151", (i - 1) * 110 + 60, -100, Transition.ColorTint, ff, 38, 38)
        GUI.SetAnchor(qualityIcon, UIAnchor.BottomLeft)
        GUI.SetPivot(qualityIcon, UIAroundPivot.Center)
        _gt.BindName(qualityIcon, "qualityIcon" .. i)

        local quality = GUI.CreateStatic(qualityIcon, "quality" .. i, sui.QualityList[i].text, 45, 0, 50, 30)
        UILayout.StaticSetFontSizeColorAlignment(quality, UIDefine.FontSizeL, UIDefine.WhiteColor, TextAnchor.UpperCenter)
        if ff then
            UILayout.StaticSetFontSizeColorAlignment(quality, UIDefine.FontSizeL, UIDefine.BrownColor, TextAnchor.UpperCenter)
        end
        GUI.SetIsOutLine(quality, true)
        GUI.SetOutLine_Color(quality, sui.QualityList[i].color)
        GUI.SetOutLine_Distance(quality, 2)
        GUI.SetAnchor(quality, UIAnchor.Center)
        GUI.SetPivot(quality, UIAroundPivot.Center)
    end

    local confirm = GUI.ButtonCreate(SaleScreeningPanelBg, "confirm", "1800102090", 0, -45, Transition.ColorTint, "<color=#ffffff><size=26>确认选择</size></color>", 160, 50, false);
    UILayout.SetAnchorAndPivot(confirm, UIAnchor.Bottom, UIAroundPivot.Center)
    GUI.ButtonSetOutLineArgs(confirm, true, Color.New(175 / 255, 96 / 255, 19 / 255, 255 / 255), 1)
    GUI.SetIsOutLine(confirm, true);
    GUI.SetOutLine_Distance(confirm, 1);
    GUI.RegisterUIEvent(confirm, UCE.PointerClick, m.script_name, sui.script_name .. "OnSelectBtnClick")
    _gt.BindName(confirm, "confirm")

end

-- 退出出售筛选页面
function sui.OnExitSaleScreeningGroup()
    local SaleScreeningGroup = _gt.GetUI("SaleScreeningGroup")
    GUI.SetVisible(SaleScreeningGroup, false)
end

function sui.CreateScreeningList()
    local screeningList = _gt.GetUI("screeningList")
    if screeningList == nil then
        return
    end
    local curCount = GUI.LoopScrollRectGetChildInPoolCount(screeningList)

    local QualityRes = UIDefine.ItemIconBg
    local icon = GUI.ItemCtrlCreate(screeningList, "icon" .. curCount, QualityRes[1], 8, 10, 90, 90, false, "system", false)
    _gt.BindName(icon, "icon" .. curCount)
    GUI.ItemCtrlSetElementRect(icon, eItemIconElement.Icon, 0, -1, 76, 76)
    GUI.RegisterUIEvent(icon, UCE.PointerClick, m.script_name, sui.script_name .. "OnChoiceTypeClick")

    -- 图片右下角勾勾
    local choiceIcon = GUI.ImageCreate(icon, "choiceIcon", "1800608400", -10, -10, false, 50, 50, false)
    GUI.SetAnchor(choiceIcon, UIAnchor.BottomRight)
    GUI.SetPivot(choiceIcon, UIAroundPivot.Center)

    -- flag 0 代表未选中， 1代表选中
    if curCount == 0 then
        GUI.SetVisible(choiceIcon, true)
        GUI.SetData(icon, "flag", 1)
    else
        GUI.SetVisible(choiceIcon, false)
        GUI.SetData(icon, "flag", 0)
    end

    -- 图片下方文字
    local text = GUI.CreateStatic(icon, "text", "装备", 0, 10, 60, 25)
    UILayout.StaticSetFontSizeColorAlignment(text, UIDefine.FontSizeS, UIDefine.BrownColor, TextAnchor.LowerCenter)
    GUI.SetAnchor(text, UIAnchor.Bottom)
    GUI.SetPivot(text, UIAroundPivot.Center)

    return icon
end

function sui.RefreshScreeningList(parameter)
    parameter = string.split(parameter, "#")
    local guid = parameter[1]
    local index = tonumber(parameter[2]) + 1

    local icon = GUI.GetByGuid(guid)
    if not icon then
        return
    end

    ItemIcon.SetEmpty(icon)

    local text = GUI.GetChild(icon, "text", false)

    GUI.ItemCtrlSetElementValue(icon, eItemIconElement.Icon, sui.SelectList[index].icon)
    GUI.StaticSetText(text, sui.SelectList[index].text)
end

function sui.OnChoiceTypeClick(guid)
    local icon = GUI.GetByGuid(guid)
    local flag = GUI.GetData(icon, "flag")
    local choiceIcon = GUI.GetChild(icon, "choiceIcon", false)

    if flag == "0" then
        GUI.SetData(icon, "flag", 1)
        GUI.SetVisible(choiceIcon, true)
    else
        GUI.SetData(icon, "flag", 0)
        GUI.SetVisible(choiceIcon, false)
    end
end

-- 筛选数据处理
function sui.OnSelectBtnClick()
    local screeningList = _gt.GetUI("screeningList")
    if screeningList == nil then
        return
    end

    -- 先存选中的品质，OnSelectAllBtnClick方法用
    sui.SelectQuality = {}
    for i = 1, #sui.QualityList + 1 do
        local qualityIcon = _gt.GetUI("qualityIcon" .. i)
        local flag2 = GUI.CheckBoxGetCheck(qualityIcon)
        if flag2 then
            sui.SelectQuality[i] = true
        end
    end

    -- 筛选出的物品
    sui.screen_items = {}
    -- 逐个选中
    for i = 1, #sui.SelectList do
        local icon = _gt.GetUI("icon" .. (i - 1))
        local flag = GUI.GetData(icon, "flag")
        if flag == "1" then
            sui.OnSelectAllBtnClick(sui.SelectList[i].text)
        end
    end

    -- 是否过滤
    local is_screen = true
    if next(sui.SelectQuality) == nil then
        is_screen = false
    end
    -- 修改可选中物品数据，将已筛选中的放前面没有筛选中的放后面，同时返回未筛选中的物品数据
    sui.SellItems, sui.not_select_items_guid = sui.processing_screen_items_data(sui.SellItems, sui.screen_items, is_screen)
    -- 第一个选中的物品的下标
    local index = 1
    if sui.SellItems ~= nil and sui.SellItems.Count > 0 then
        -- 已选中物品列表中有数据
        if next(sui.SellSelectItemLst) ~= nil then
            -- 遍历能够选中的物品列表
            for k, v in pairs(sui.SellItems) do
                if type(v) == 'userdata' and v.guid then
                    if sui.SellSelectItemLst[tostring(v.guid)] then
                        index = k
                        break
                    end
                end
            end
        end
        -- 刷新物品详情页面
        local itemData = sui.SellItems[index]
        sui.ShowDetailInfo(sui.PackRealItemInfos(sui.SellItems[index].id, sui.SellItems[index].dyn_attrs, sui.SellItems[index].isbound == 1 and true or false, sui.SellItems[index].amount, true, itemData), sui.panelBg, sui.tabIndex, _gt)
    end

    -- 物品详情页中物品选中的数量
    local select_item_guid = tostring(sui.SellItems[index].guid)
    local count = (sui.SellSelectItemLst[select_item_guid] and sui.SellSelectItemLst[select_item_guid].count) or 0
    sui.ShowSellNumNode(true)
    sui.SetSellNum(count)

    -- 刷新物品格列表
    sui.SelectSellItemIndex = index
    if sui.SellItems ~= nil then
        local Count = sui.SellItems.Count
        --包裹更新了，刷新数据
        local sellCount = ((Count <= sui.ONEPAGE_COUNT) and sui.ONEPAGE_COUNT) or (math.ceil(Count / sui.ITEM_BOXES_LINE_COUNT) * sui.ITEM_BOXES_LINE_COUNT)
        sui.cre_and_ref_sell_item_scroll(sellCount, sui.sell_scroll_num_max)
    end

    -- 设置在物品格列表中当前选中的物品格
    sui.PressedItemGuid = nil
    local name = "ItemIconBg" .. index
    local btn = _gt.GetUI(name)
    if btn then
        sui.PressedItemGuid = GUI.GetGuid(btn)
    end
    -- 关闭筛选界面
    sui.OnExitSaleScreeningGroup()
end

-- 根据传入的分类选中物品
function sui.OnSelectAllBtnClick(condition)
    --sui.SellSelectItemLst = {}
    if sui.SellItems ~= nil then
        local Count = sui.SellItems.Count
        for i = 0, Count - 1 do
            local itemGUID = tostring(sui.SellItems[i + 1].guid)
            local config = DB.GetOnceItemByKey1(sui.SellItems[i + 1].id)
            local setFlag = false

            if sui.SelectQuality[config.Grade] then
                if config.Type == sui.ruleType[condition].Type and config ~= nil then
                    setFlag = true

                    -- 宝石的特殊情况单独判断下
                    if condition == "材料" and config.Subtype == 9 then
                        setFlag = false
                    end

                    if condition == "宝石" and config.Subtype ~= 9 then
                        setFlag = false
                    end
                end

                -- 藏宝图归属到消耗品下
                if config.Type == 4 and condition == "消耗品" then
                    setFlag = true
                end
            end

            if setFlag then
                sui.screen_items[itemGUID] = { count = sui.SellItems[i + 1].amount, total = sui.SellItems[i + 1].amount, price = config.SaleGoldBind, guid = itemGUID, id = config.Id }
            end
        end
    end
end

-- 筛选物品数据处理
---@param can_select_items table 可以选中的物品列表
---@param already_select_items table 已经筛选出的物品列表
---@param is_screen boolean 是否过滤
---@return table tab 已筛选在前未筛选中在后的可选中物品列表
---@return table not_select_items_guid 未筛选中物品列表
sui.processing_screen_items_data = function(can_select_items, already_select_items, is_screen)
    if is_screen == false then
        table.sort(can_select_items, sui.item_sort)
        return can_select_items, {}
    end
    if next(already_select_items) == nil then
        -- Count属性是key值未参与排序
        table.sort(can_select_items, sui.item_sort)
        -- 未筛选中的物品数据
        local not_select_items_guid = {}
        for _, v in pairs(can_select_items) do
            if type(v) == 'userdata' and v.guid then
                not_select_items_guid[tostring(v.guid)] = true
            end
        end
        return can_select_items, not_select_items_guid
    end
    local tab = {}
    -- 未筛选中物品数据guid 因为无法在userdata数据中创建数据 迫于无奈 只能新建个表
    local not_select_items_guid = {}
    -- 未筛选中的列表
    local not_select_items = {}
    -- 已筛选中列表
    local select_items = {}
    for _, v in pairs(can_select_items) do
        if type(v) == 'userdata' and v.guid then
            -- 未选中
            if already_select_items[tostring(v.guid)] == nil then
                -- 是否未被选中 因为是userdata数据无法创建
                --v.is_not_select = true
                not_select_items_guid[tostring(v.guid)] = true
                table.insert(not_select_items, v)
                -- 已选中
            else
                --v.is_not_select = nil
                not_select_items_guid[v.guid] = nil
                table.insert(select_items, v)
            end
        end
    end
    table.sort(not_select_items, sui.item_sort)
    table.sort(select_items, sui.item_sort)

    -- 封装成返回数据
    for _, v in ipairs(select_items) do
        table.insert(tab, v)
    end
    for _, v in ipairs(not_select_items) do
        table.insert(tab, v)
    end
    tab.Count = #tab
    return tab, not_select_items_guid
end